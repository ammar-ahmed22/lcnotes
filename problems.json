{
    "two-sum": {
        "id": "two-sum",
        "title": "1. Two Sum",
        "directory": "1-two-sum",
        "difficulty": "Easy",
        "tags": [
            "hashmap",
            "math"
        ],
        "notes": "- **Intuition**: To find a valid answer we simply need to find if the complement (`target - curr`) exists in the array\n- **Implementation**: Use a hashmap to store numbers with their indices (allow overwrites because duplicates are not allowed), check if the complement exists in the map and is not the same number, return\n- **Edge-cases**: Ensure that you check the indices are not the same when returning (i.e. `map[complement] != i`)\n- **Complexity**: Time `O(n)`, Space `O(n)` (hashmap)\n",
        "published": true,
        "datetime": "2025-12-22T09:18:55Z"
    },
    "contains-duplicate": {
        "id": "contains-duplicate",
        "title": "217. Contains Duplicate",
        "directory": "217-contains-duplicate",
        "difficulty": "Easy",
        "tags": [
            "hashmap"
        ],
        "notes": "- **Intuition**: Need to check if a given number exists in the array\n- **Implementation**: Use a hashmap, check if the current number is in the map, return True if found, otherwise add to map, return False at the end of loop (no duplicates found)\n- **Complexity**: Time `O(n)`, Space `O(n)` (hashmap)\n",
        "published": true,
        "datetime": "2025-12-22T09:19:02Z"
    },
    "valid-anagram": {
        "id": "valid-anagram",
        "title": "242. Valid Anagram",
        "directory": "242-valid-anagram",
        "difficulty": "Easy",
        "tags": [
            "hashmap",
            "frequency"
        ],
        "notes": "- **Intuition**: An anagram means the strings have the same frequency of letters, i.e. abc is anagram of bac or cab, etc.\n- **Implementation**: Since only lowercase alphabet, increment in 26 value array at each character index (i.e. a = index 0, b = index 1, etc.) for `s` and decrement for `t`, if frequency array is zero, return True, otherwise False\n- **Complexity**: Time `O(n)`, Space `O(1)` (freq is 26 values, const.)\n",
        "published": true,
        "datetime": "2025-12-22T09:19:12Z"
    },
    "group-anagrams": {
        "id": "group-anagrams",
        "title": "49. Group Anagrams",
        "directory": "49-group-anagrams",
        "difficulty": "Medium",
        "tags": [
            "hashmap",
            "frequency"
        ],
        "notes": "- **Intuition**: Every \"group\" of anagrams will have the same frequency table (26 value array)\n- **Implementation**: Use a hashmap with the key being the frequency table and the value being the group of strings, iterate over each string, create the frequency table, check the map, add or create new entry in the map, finally take all the values from the map and flatten into a single result\n- **Edge-cases**: Python doesn't allow arbitrary values as keys, convert frequency table to comma-separated string\n- **Complexity**: Time `O(n)`, Space `O(n)` (hashmap)\n",
        "published": true,
        "datetime": "2025-12-22T09:19:22Z"
    },
    "top-k-frequent-elements": {
        "id": "top-k-frequent-elements",
        "title": "347. Top K Frequent Elements",
        "directory": "347-top-k-frequent-elements",
        "difficulty": "Medium",
        "tags": [
            "hashmap",
            "frequency"
        ],
        "notes": "- **Intuition**: We can use an array that maps index to frequency (i.e. freq[1] = 2 means 2 has a frequency of 1), allowing us to formulate the answer in `O(n)` time\n- **Implementation**: Use a hashmap to count frequencies, iterate over hashmap and create our frequency array (length `n + 1`, 1-based indexing), iterate backwards over frequency array to create result\n- **Edge-cases**: Multiple elements can have the same frequency so frequency array should be an array of arrays, when iterating backwards go into arrays if needed\n- **Complexity**: Time `O(n)`, Space `O(n)` (freq map)\n",
        "published": true,
        "datetime": "2025-12-22T09:19:31Z"
    },
    "product-of-array-except-self": {
        "id": "product-of-array-except-self",
        "title": "238. Product of Array Except Self",
        "directory": "238-product-of-array-except-self",
        "difficulty": "Medium",
        "tags": [
            "math"
        ],
        "notes": "- **Intuition**: Use `prefix` and `suffix` arrays to calculate answer at each index. `prefix` is the product of all elements before `i` and `suffix` is the product of all elements after `i`.\n- **Implementation**: Initialize `prefix` with `1` (before `i = 0` is just 1), iterate from `1 to n`, `prefix[i] = nums[i - 1] * prefix[i - 1]`. Initialize `suffix` with `suffix[-1] = 1` (after the end of the array, just 1 left), iterate backwards `n-2 to 0`, `suffix[i] = nums[i + 1] * suffix[i + 1]`. Answer is `ans[i] = prefix[i] * suffix[i]`\n- **Complexity**: Time `O(n)`, Space `O(n)` (prefix and suffix arrays)\n",
        "published": true,
        "datetime": "2025-12-22T09:19:39Z"
    },
    "valid-sudoku": {
        "id": "valid-sudoku",
        "title": "36. Valid Sudoku",
        "directory": "36-valid-sudoku",
        "difficulty": "Medium",
        "tags": [
            "matrix"
        ],
        "notes": "- **Intuition**: Check each row, column and 3x3 subbox for duplicates essentially\n- **Implementation**: Use a hashmap to check for duplicates in each row, column and 3x3 subbox\n- **Edge-cases**: Figuring out the indexing of the 3x3 subbox is difficult. Do 4 nested loops, `box_row (0 to 3)`, `box_col (0 to 3)`, `row (0 to 3)`, `col (0 to 3)`, then we can access the specific value with `board[3 * box_row + row][3  * box_col + col]`\n- **Complexity**: Time `O(n^2)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:19:52Z"
    },
    "longest-consecutive-sequence": {
        "id": "longest-consecutive-sequence",
        "title": "128. Longest Consecutive Sequence",
        "directory": "128-longest-consecutive-sequence",
        "difficulty": "Medium",
        "tags": [
            "hashmap",
            "math"
        ],
        "notes": "- **Intuition**: The start of a sequence is when there IS a number exactly 1 greater than it in the array and NOT a number exactly 1 less than it. When a sequence start is found, iterate looking for the next values, keeping track of the max length\n- **Implementation**: Use hashmap to store all numbers for `O(1)` lookup, iterate and look for sequence start, iterate building the sequence and keep track of max\n- **Edge-cases**: In case of duplicates, we don't process the same sequence start multiple times. Initialize hashmap with all `False` values, when processing a sequence start, mark it as `True` to signify this sequence start is already processed and don't process that sequence start again\n- **Complexity**: Time `O(n)`, Space `O(n)` (hashmap)\n",
        "published": true,
        "datetime": "2025-12-22T09:20:01Z"
    },
    "valid-palindrome": {
        "id": "valid-palindrome",
        "title": "125. Valid Palindrome",
        "directory": "125-valid-palindrome",
        "difficulty": "Easy",
        "tags": [
            "two-pointers",
            "string"
        ],
        "notes": "- **Intuition**: Palindrome will have the same characters on the left and right side of the string when traversing at the same speed\n- **Implementation**: Use right and left pointers, iterate towards the center, check if `l == r`, if not, early return `False`. Otherwise return `True`.\n- **Edge-cases**: Can have non-alphanumeric or uppercase characters, make everything lowercase, skip over non-alphanumerics\n- **Complexity**: Time `O(n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:20:13Z"
    },
    "two-sum-ii-input-array-is-sorted": {
        "id": "two-sum-ii-input-array-is-sorted",
        "title": "167. Two Sum II - Input Array Is Sorted",
        "directory": "167-two-sum-ii-input-array-is-sorted",
        "difficulty": "Medium",
        "tags": [
            "two-pointers",
            "binary-search"
        ],
        "notes": "- **Intuition**: Since array is sorted, we only need to look for our complment (`target - curr`) in the values to the right of the current (also sorted, binary search)\n- **Implementation**: For each number, calculate the complement, conduct binary search on the elements to the right of it, if not found keep going, if found return\n- **Complexity**: Time `O(log n)`, Space `O(1)`\n\n",
        "published": true,
        "datetime": "2025-12-22T09:20:24Z"
    },
    "3sum": {
        "id": "3sum",
        "title": "15. 3Sum",
        "directory": "15-3sum",
        "difficulty": "Medium",
        "tags": [
            "binary-search",
            "two-pointers"
        ],
        "notes": "- **Intuition**: Use a similar approach to [Two Sum II - Input Array Sorted](../167-two-sum-ii-input-array-is-sorted/solution.py), sort the input, look for when left and right of the right side of the array add up to the current number\n- **Implementation**: Sort the input `O(n log n)`, for each number, binary search on the right side of the array, if `l + r = curr`, triplet found, add to result, move right if `l + r` is too big, otherwise move left\n- **Edge-cases**: Ensure that we keep going even after finding a triplet because there could be more with the same `curr`. Also ensure that we move past duplicates for `curr` because it will be the same result, i.e. if we have [-1, -1, -1, 0, 1], we want to start processing at the last -1. Same thing when we find an answer, we want to move left and right until they are at the next non-duplicate\n- **Complexity**: Time `O(n^2 log n)` (sorting, nested loop), Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:20:38Z"
    },
    "container-with-most-water": {
        "id": "container-with-most-water",
        "title": "11. Container With Most Water",
        "directory": "11-container-with-most-water",
        "difficulty": "Medium",
        "tags": [
            "two-pointers",
            "math"
        ],
        "notes": "- **Intuition**: We want to maximize height and width. Start with max width and always reduce the width towards the larger height.\n- **Implementation**: Left and right pointers at the end of the array. Keep track of max area using min of left and right as height. Move right or left pointer towards the larger one. i.e. if left > right, move right. if right > left, move left.\n- **Complexity**: Time `O(n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:20:47Z"
    },
    "valid-parentheses": {
        "id": "valid-parentheses",
        "title": "20. Valid Parentheses",
        "directory": "20-valid-parentheses",
        "difficulty": "Easy",
        "tags": [
            "stack"
        ],
        "notes": "- **Intuition**: Every opening bracket should eventually have a closing bracket that comes after it.\n- **Implementation**: Use a stack and a map that maps opening brackets to closing, when seeing an opening bracket, push the closing bracket to the stack, When seeing a closing bracket, check the top of the stack, if its the same, pop and keep going, otherwise return `False`.\n- **Edge-cases**: At the end, check the stack should be empty (unclosed brackets at the end). Also check if the stack is empty on seeing a closing bracket, return `False` there was no corresponding open.\n- **Complexity**: Time `O(n)`, Space `O(n)` (stack)\n",
        "published": true,
        "datetime": "2025-12-22T09:20:52Z"
    },
    "min-stack": {
        "id": "min-stack",
        "title": "155. Min Stack",
        "directory": "155-min-stack",
        "difficulty": "Medium",
        "tags": [
            "stack"
        ],
        "notes": "- **Intuition**: Use two stacks, one to track the min values and one for the actual stack\n- **Implementation**: Initialize two stacks. `getMin` gets the top of the min stack if it has elements, otherwise top of main stack. `top` gets the top of the main stack always. `push` will always push to main stack, checks if the number is less than or equal to the min or if the stack is empty and pushes to the min stack, `pop` will check if the current top is equal to the min, pop from min stack, always pop from main stack after.\n- **Complexity**: Time `O(1)` for `getMin`, Space `O(n)` (stack)\n",
        "published": true,
        "datetime": "2025-12-22T09:20:59Z"
    },
    "evaluate-reverse-polish-notation": {
        "id": "evaluate-reverse-polish-notation",
        "title": "150. Evaluate Reverse Polish Notation",
        "directory": "150-evaluate-reverse-polish-notation",
        "difficulty": "Medium",
        "tags": [
            "stack",
            "math"
        ],
        "notes": "- **Intuition**: In RPN, every operator operates on the last two elements while ensuring the results of all operations are continously updated.\n- **Implementation**: Use a stack, whenever a number is seen, add to stack. When an operator seen, pop the last 2 and operate on them, push the result back to the stack and keep going. Return top of stack at the end.\n- **Edge-cases**: In Python, integer division (`a // b`) does not truncate to zero, use `int(b / a)`. Remember order for division and subtraction matter, its `b - a` and `int(b / a)`.\n- **Complexity**: Time `O(n)`, Space `O(n)` (stack)\n",
        "published": true,
        "datetime": "2025-12-22T09:21:09Z"
    },
    "generate-parentheses": {
        "id": "generate-parentheses",
        "title": "22. Generate Parentheses",
        "directory": "22-generate-parentheses",
        "difficulty": "Medium",
        "tags": [
            "stack",
            "recursion"
        ],
        "notes": "- **Intuition**: Recursively generate by going down the different possible paths to make a well-formed parentheses set. Open and closed must both equal n for it to be well-formed\n- **Implementation**: Recursive function that takes open, closed, n, stack and result. Base case `open == close == n`, form the string from the stack and add to result. Otherwise, check if `open < n`, add open to stack, recurse with new count, pop from stack after to go down other path. Check if `closed < open` (other path), add close to stack, recurse with new count, pop from stack.\n- **Complexity**: Time is complex, something to do with the n-th Catalan number: `O(1 / (n + 1) * 2nCn * n)`, Space `O(n)` (call stack)\n",
        "published": true,
        "datetime": "2025-12-22T09:21:18Z"
    },
    "daily-temperatures": {
        "id": "daily-temperatures",
        "title": "739. Daily Temperatures",
        "directory": "739-daily-temperatures",
        "difficulty": "Medium",
        "tags": [
            "stack"
        ],
        "notes": "- **Intuition**: Store the temperature until a greater temperature is found.\n- **Implementation**: Initialize result with all zeros, we will add in values when we find the larger one. Use a stack to store both temp and index, iterate, while stack is not empty and stack top temp is less than curr, pop from stack, calculate distance with indices, add to result at popped index. Add curr temp and index to stack.\n- **Complexity**: Time `O(n)`, Space `O(n)` (stack)\n",
        "published": true,
        "datetime": "2025-12-22T09:21:24Z"
    },
    "car-fleet": {
        "id": "car-fleet",
        "title": "853. Car Fleet",
        "directory": "853-car-fleet",
        "difficulty": "Medium",
        "tags": [
            "stack",
            "math"
        ],
        "notes": "- **Intuition**: The car's ahead will be always be limiting the cars before if there is any limiting\n- **Implementation**: Combine pos and speed and sort them by position in reverse order (descending). Stack to store the time to target for the limiting cars. On each iteration, calculate the time to target, if it's greater than the top of the stack, push. Length of stack is the answer.\n- **Complexity**: Time `O(n log n)` (sorting), Space `O(n)`\n",
        "published": true,
        "datetime": "2025-12-22T09:21:32Z"
    },
    "largest-rectangle-in-histogram": {
        "id": "largest-rectangle-in-histogram",
        "title": "84. Largest Rectangle in Histogram",
        "directory": "84-largest-rectangle-in-histogram",
        "difficulty": "Hard",
        "tags": [
            "stack",
            "math"
        ],
        "notes": "- **Intuition**: We only want to increase the width when we find a taller line that can potentially form a larger area with a previous line.\n- **Implementation**: Use a stack and keep track of max area. Stack will store indices of the lines. Iterate from 0 to n + 1. curr is the current height or 0. If current is less than the top of the stack, pop from stack as our height and calculate area with the smaller height before it (top of stack after popping). Update max area. Push current index to stack.\n- **Edge-cases**: When stack is empty after popping, the left index can be set to -1 to calculate width correctly.\n- **Complexity**: Time `O(n)`, Space `O(n)` (stack)\n",
        "published": true,
        "datetime": "2025-12-22T09:21:38Z"
    },
    "binary-search": {
        "id": "binary-search",
        "title": "704. Binary Search",
        "directory": "704-binary-search",
        "difficulty": "Easy",
        "tags": [
            "binary-search"
        ],
        "notes": "- **Intuition**: Cut the search area in half each time.\n- **Implementation**: Left and right pointers, iterate while left less than or equal to right. Calculate mid point. If mid equal to target, return. Otherwise, if middle is less than target, value is in right side of array, move left pointer to mid + 1. Otherwise, value is in left side, move right to mid - 1. Iteration finishes, return -1 (not found).\n- **Edge-cases**: Iterating while left less than or EQUAL to right.\n- **Complexity**: Time `O(log n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:21:50Z"
    },
    "search-a-2d-matrix": {
        "id": "search-a-2d-matrix",
        "title": "74. Search a 2D Matrix",
        "directory": "74-search-a-2d-matrix",
        "difficulty": "Medium",
        "tags": [
            "binary-search",
            "matrix"
        ],
        "notes": "- **Intuition**: Nested binary search. Find the row, then find the value.\n- **Implementation**: Start with binary search for the rows, found condition is if the first value in the row is less than or equal to target and last value is greater than or equal to target. Binary search on the row as usual.\n- **Edge-cases**: If the nested search (row search) completes without early return, return False right afterwards, do not continue.\n- **Complexity**: Time `O(log n * log m)` (binary search on rows, then cols), Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:22:00Z"
    },
    "koko-eating-bananas": {
        "id": "koko-eating-bananas",
        "title": "875. Koko Eating Bananas",
        "directory": "875-koko-eating-bananas",
        "difficulty": "Medium",
        "tags": [
            "binary-search",
            "math"
        ],
        "notes": "- **Intuition**: The max eating speed will be the max value in the piles.\n- **Implementation**: Binary search from 1 to the max value in piles. On each iteration, calculate the hours required. If the hours is greater than the provided hours, increase the speed (look in the right side). Otherwise left side. When iterating stops, answer will be the left value.\n- **Edge-cases**: Use `ceil` when calculating the hours because the you can't have 0 bananas eaten.\n- **Complexity**: Time `O(log n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:22:08Z"
    },
    "find-minimum-in-rotated-sorted-array": {
        "id": "find-minimum-in-rotated-sorted-array",
        "title": "153. Find Minimum in Rotated Sorted Array",
        "directory": "153-find-minimum-in-rotated-sorted-array",
        "difficulty": "Medium",
        "tags": [
            "binary-search"
        ],
        "notes": "- **Intuition**: The number before and after the min will be greater than it.\n- **Implementation**: Binary search, check for number before and after being greater as stop condition. Move towards the smaller value out of right and left.\n- **Edge-cases**: Also check if the mid value is zero and end of array in stop condition check to mitigate out of bound errors.\n- **Complexity**: Time `O(log n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:22:15Z"
    },
    "search-in-rotated-sorted-array": {
        "id": "search-in-rotated-sorted-array",
        "title": "33. Search in Rotated Sorted Array",
        "directory": "33-search-in-rotated-sorted-array",
        "difficulty": "Medium",
        "tags": [
            "binary-search"
        ],
        "notes": "- **Intuition**: Minimum in rotated sorted array is the pivot index, use that to determine which \"side\" of the array to search in.\n- **Implementation**: Binary search on the whole array to find the pivot index using the minimum in rotated sorted array algo (num before and fter mid should be greater for stop condition, move towards smaller out of left and right). Minimum is the pivot index. Check if the target is in between 0 and pivot, binary search from 0 to pivot. Otherwise binary search from pivot to end.\n- **Edge-cases**: Check if target is in between `0` and `pivot - 1` for the final binary search check.\n- **Complexity**: Time `O(log n)` (binary search), Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:22:23Z"
    },
    "best-time-to-buy-and-sell-stock": {
        "id": "best-time-to-buy-and-sell-stock",
        "title": "121. Best Time to Buy and Sell Stock",
        "directory": "121-best-time-to-buy-and-sell-stock",
        "difficulty": "Easy",
        "tags": [
            "sliding-window"
        ],
        "notes": "- **Intuition**: Selling is always after buying. When finding a good small price, keep checking later days for better profit.\n- **Implementation**: Two pointers, `buy` and `sell` initialized to `0` and `1`. Iterate while `sell < len(prices)`. Calculate profit, if its greater than 0, update max profit. If not, set `buy` to `sell`, restart the window at the `sell` spot. Always increment `sell`. \n- **Edge-cases**: If `prices <= 1`, return 0 (no profit possible). \n- **Complexity**: Time `O(n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T09:22:31Z"
    },
    "longest-substring-without-repeating-characters": {
        "id": "longest-substring-without-repeating-characters",
        "title": "3. Longest Substring Without Repeating Characters",
        "directory": "3-longest-substring-without-repeating-characters",
        "difficulty": "Medium",
        "tags": [
            "sliding-window"
        ],
        "notes": "- **Intuition**: Slide a window by removing from the left when a character is seen again on the right\n- **Implementation**: Use a set. Iterate with the right pointer, initialize a left pointer. If the right character is in the set, remove from the left side, increment left. Add the right character to set after the check. Keep track of max length after the check.\n- **Edge-cases**: Window size will be `r - l + 1`\n- **Complexity**: Time `O(n)`, Space `O(n)` (set)\n",
        "published": true,
        "datetime": "2025-12-22T09:22:40Z"
    },
    "longest-repeating-character-replacement": {
        "id": "longest-repeating-character-replacement",
        "title": "424. Longest Repeating Character Replacement",
        "directory": "424-longest-repeating-character-replacement",
        "difficulty": "Medium",
        "tags": [
            "sliding-window"
        ],
        "notes": "- **Intuition**: Only 26 characters possible. In each window, the number of operations to make them all the same is the max frequency of the window minus the window length. Reduce the window until this condition is satisfied.\n- **Implementation**: Create a frequency array (26 value array). Iterate with `r` pointer. Increment the character at `r` in the frequency array. Update the max frequency with the frequency value of the value at `r` (new value added). If the number of operations (`windowLen - maxFreq`) is greater than `k`, increment l (reduce window size) and decrement the frequency value.\n- **Edge-cases**: Window size is calculated with `r - l + 1`.\n- **Complexity**: Time `O(n)`, Space `O(1)` (freq is 26 values, const.)\n",
        "published": true,
        "datetime": "2025-12-22T09:22:51Z"
    },
    "permutation-in-string": {
        "id": "permutation-in-string",
        "title": "567. Permutation in String",
        "directory": "567-permutation-in-string",
        "difficulty": "Medium",
        "tags": [
            "sliding-window"
        ],
        "notes": "- **Intuition**: Only 26 characters possible. Slide window of `len(s1)` across `s2` and check if the frequencies match up.\n- **Implementation**: Can use a single frequency map. Populate frequency map with characters from `s1`. Decrement frequency map with characters from `s2` up to `len(s1)` (first window). Initialize `r` to length of `s1` (first window already computed). Iterate while `r` is less than `len(s2)`. Check if frequency map is all zeros, early return. Increment value at left from frequency map (leaving window), decrement value at right from frequency map (entering window). Increment both l and r (they are already spaced at the correct window length).\n- **Edge-cases**: Early return at the start if `len(s1) > len(s2)`. Ensure to do a check at the end for the frequency map being zeros.\n- **Complexity**: Time `O(n)`, Space `O(1)` (freq is 26 values, const.)\n",
        "published": true,
        "datetime": "2025-12-22T09:22:58Z"
    },
    "minimum-window-substring": {
        "id": "minimum-window-substring",
        "title": "76. Minimum Window Substring",
        "directory": "76-minimum-window-substring",
        "difficulty": "Hard",
        "tags": [
            "sliding-window"
        ],
        "notes": "- **Intuition**: Frequency map created with chars of `t`, substring will be valid if when substracting frequencies from the same map are all less than or equal to zero.\n- **Implementation**: Create a frequency map of all characters in `t`. The minimum window size will be of length `t`, start `r` there. Process the first window first by iteration from `0` to `r` and subtracting from the map if the character exists. Iterate while `r` is less than `s`. Check if the current substring is valid by checking if the map has all `<= 0`. If it is valid, update the minimum string if needed. Always reduce the window when valid by incrementing `l` and updating the map. Only increment `r` when it's invalid or the length of the window has reached the minimum length (`len(t)`).\n- **Edge-cases**: When incrementing `r`, the frequency map should be updated AFTER. When incrementing `l`, frequency map should be updated BEFORE. Aeeswer is initialized to `\"\"` so check for that as well (see solution).\n- **Complexity**: Time `O(m)` (sliding window across `s`), Space `O(n)` (hashmap for `t`), where `m` is the length of `s` and `n` is the length of `t`.\n",
        "published": true,
        "datetime": "2025-12-22T09:58:11Z"
    },
    "reverse-linked-list": {
        "id": "reverse-linked-list",
        "title": "206. Reverse Linked List",
        "directory": "206-reverse-linked-list",
        "difficulty": "Easy",
        "tags": [
            "linked-list"
        ],
        "notes": "- **Intuition**: Iterate through reversing the links.\n- **Implementation**: `curr` pointer (initialized to `head`) and `prev` pointer (initialized to `None`). Iterate while `curr` is not `None`. Save `curr.next` into a temporary var because it will be needed. Set `curr.next` to `prev`. Set `prev` to `curr` and set `curr` to `temp`.\n- **Edge-cases**: Go through the ordering of how everything is set conceptually.\n- **Complexity**: Time `O(n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T22:43:29Z"
    },
    "merge-two-sorted-lists": {
        "id": "merge-two-sorted-lists",
        "title": "21. Merge Two Sorted Lists",
        "directory": "21-merge-two-sorted-lists",
        "difficulty": "Easy",
        "tags": [
            "linked-list"
        ],
        "notes": "- **Intuition**: Iterate the lists together, smaller ones going in first.\n- **Implementation**: Pointers for `list1`, `l1` and `list2`, `l2`. Create a dummy node for the result, set the `curr` pointer to the dummy. Iterate while `l1` and `l2` are not `None`. If `l1` value is less than `l2` val, set `curr.next` to a new node with that value. Update the curr pointer and the `l1` pointer. Else, set `curr.next` to a new node with that value. Update the curr pointer and the `l2` pointer. After the first iteration completes, one of `l1` or `l2` might still be not fully complete. Iterate through both of them the same way as above to finish it off. Return `dummy.next`.\n- **Complexity**: Time `O(m + n)` where `m` is length of `list1` and `n` is the length of `list2`, Space `O(1)` \n",
        "published": true,
        "datetime": "2025-12-22T22:55:29Z"
    },
    "linked-list-cycle": {
        "id": "linked-list-cycle",
        "title": "141. Linked List Cycle",
        "directory": "141-linked-list-cycle",
        "difficulty": "Easy",
        "tags": [
            "linked-list"
        ],
        "notes": "- **Intuition**: With fast and slow pointers, if there is a cycle they will eventually meet up.\n- **Implementation**: `slow` and `fast` pointers initialized to head. Iterate while `fast` and `fast.next` is not `None`. Update `slow` with `slow.next` and update `fast` with `fast.next.next`. After updating, if `fast == slow`, cycle found, early return `True`. Otherwise, if iteration completes (no cycle), return `False`.\n- **Complexity**: Time `O(n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-22T23:31:36Z"
    },
    "reorder-list": {
        "id": "reorder-list",
        "title": "143. Reorder List",
        "directory": "143-reorder-list",
        "difficulty": "Medium",
        "tags": [
            "linked-list"
        ],
        "notes": "- **Intuition**: Reverse the second half of the list and merge the two together. \n- **Implementation**: Find the midpoint with slow and fast pointers, fast starting at `head.next`. Reverse the second half by starting at `slow.next`. Break the link in the original list by setting `slow.next` to `None`. Merge the two lists together by creating two pointers, `first` and `second`. Iterate while `second` is not `None`. Save the next values of first and second in temp variables. Set `first.next` to `second`. Set `second.next` to `temp1`, Increment by setting first to `temp1`, second to `temp2`.\n- **Complexity**: Time `O(n)` (3 operations sequentially, all `O(n)`), Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-23T22:09:36Z"
    },
    "invert-binary-tree": {
        "id": "invert-binary-tree",
        "title": "226. Invert Binary Tree",
        "directory": "226-invert-binary-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "bfs"
        ],
        "notes": "- **Intuition**: Use BFS and swap (can also use DFS)\n- **Implementation**: Early return if root is None. Initialize a queue with `root`. Iterate while `q` is not empty. Pop node from the left, swap right and left. If node has left, push to queue, if node has right push to queue. Return `root`\n- **Complexity**: Time `O(n)`, Space `O(n)` queue.\n",
        "published": true,
        "datetime": "2025-12-23T23:19:16Z"
    },
    "maximum-depth-of-binary-tree": {
        "id": "maximum-depth-of-binary-tree",
        "title": "104. Maximum Depth of Binary Tree",
        "directory": "104-maximum-depth-of-binary-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "- **Intuition**: DFS on the tree taking the max of left and right, increasing depth count each time.\n- **Implementation**: Create a `dfs` recursive function that takes in the `root` and the `depth`. Base case, `root` is `None`, return `depth`. Otherwise, recursve with max of the `dfs` call on the left and the right with `depth + 1`.\n- **Complexity**: Time `O(n)`, Space `O(n)` (recursive call stack)\n",
        "published": true,
        "datetime": "2025-12-23T23:32:18Z"
    },
    "diameter-of-binary-tree": {
        "id": "diameter-of-binary-tree",
        "title": "543. Diameter of Binary Tree",
        "directory": "543-diameter-of-binary-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "- **Intuition**: The maximum of the heights through any given node will be the diameter.\n- **Implementation**: Use DFS. The recursive function will calculate the height of the tree as well as update a global `res` value for the answer. Base case is if `root` is `None`, return `0`. Otherwise, `dfs` on `left` and `right`. Update global `res` with max of left and right calculation. Recurse with `1 + max(left, right)`.\n- **Edge-cases**: In Python, variable scoped outside of the closure must be initialized inside it with `nonlocal` keyword (see solution).\n- **Complexity**: Time `O(n)`, Space `O(n)` (call stack)\n",
        "published": true,
        "datetime": "2025-12-24T05:55:35Z"
    },
    "remove-nth-node-from-end-of-list": {
        "id": "remove-nth-node-from-end-of-list",
        "title": "19. Remove Nth Node From End of List",
        "directory": "19-remove-nth-node-from-end-of-list",
        "difficulty": "Medium",
        "tags": [
            "linked-list"
        ],
        "notes": "- **Intuition**: Two pointers delayed by `n`.\n- **Implementation**: Move the right pointer `n` spaces. Create a dummy node and set the `next` value to the input list (to handle the case of having nothing in the input or just a single node). Set the left pointer to the dummy node. Iterate while `right` is not none and increment both left and right. When finished, `left` will be at the correct position. Set `left.next` to `left.next.next` (skip over one).\n- **Complexity**: Time `O(n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-24T07:25:36Z"
    },
    "add-two-numbers": {
        "id": "add-two-numbers",
        "title": "2. Add Two Numbers",
        "directory": "2-add-two-numbers",
        "difficulty": "Medium",
        "tags": [
            "linked-list",
            "math"
        ],
        "notes": "- **Intuition**: Add like on paper with carrying over logic.\n- **Implementation**: Create a dummy node for the result. Intialize two pointers for each list, `p1` and `p2`. Initialize a pointe for the dummy, `curr`. Initialize `carry` value to zero. Iterate while `p1` and `p2` are not`None`. Calculate the total with `p1.val + p2.val + carry`. The new node's value is set to this `tot` and the carry is set to zero. If the total is greater than or equal to 10 (i.e. we have to carry), update the value to `tot % 10` and the `carry` to `tot // 10`. After the main iteration, there may still be residual values in `p1` OR `p2` repeat the same logic for both lists individually. At the end, carry may still have value, if it does create a final node with the carry value. \n- **Edge-cases**: Rememver to handle the case of the `carry` still have a value at the end of all iterations.\n- **Complexity**: Time `O(n)`, Space `O(1)` (result does not count)\n",
        "published": true,
        "datetime": "2025-12-24T07:52:29Z"
    },
    "find-the-duplicate-number": {
        "id": "find-the-duplicate-number",
        "title": "287. Find the Duplicate Number",
        "directory": "287-find-the-duplicate-number",
        "difficulty": "Medium",
        "tags": [
            "linked-list",
            "array"
        ],
        "notes": "- **Intuition**: Treat like linked list with indices as values, array values as next pointers. Duplicate causes cycle, need to find start of cycle (will not always be at the end).\n- **Implementation**: First, we need to move a pointer into the cycle by using fast and slow pointers. When they are equal, slow pointer will be inside the cycle. Break the iteration. After this intialize a new pointer at the start, continue iterating slow and the new pointer until they meet, now slow will be at the start of the cycle (duplicate).\n- **Edge-cases**: Remember the second iteration, slow and fast only finds if a cycle exists not the start of it.\n- **Complexity**: Time `O(n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-24T22:33:29Z"
    },
    "trapping-rain-water": {
        "id": "trapping-rain-water",
        "title": "42. Trapping Rain Water",
        "directory": "42-trapping-rain-water",
        "difficulty": "Hard",
        "tags": [
            "two-pointers",
            "math"
        ],
        "notes": "- **Intuition**: Water trapped at any point is bounded by smaller of the maxes on left and right.\n- **Implementation**: Two pointer approach with tracking of left and right max. Initialize two pointers on left and right. Initialize trackers for left and right max, `maxL` and `maxR`. Iterate while `l < r`. On each iteration, update `maxL` and `maxR` with appropriate values (`height[l]` and `height[r]`). If `maxL <= maxR`, the water is bounded only by the left value (already a larger value on the right). Update answer with `maxL - height[l]` and move left. Otherwise, answer is bounded by right value only (already a larger value on the left). Update answer with `maxR - height[r]` and move right.\n- **Complexity**: Time `O(n)`, Space `O(1)`\n",
        "published": true,
        "datetime": "2025-12-26T20:38:36Z"
    },
    "sliding-window-maximum": {
        "id": "sliding-window-maximum",
        "title": "239. Sliding Window Maximum",
        "directory": "239-sliding-window-maximum",
        "difficulty": "Hard",
        "tags": [
            "sliding-window"
        ],
        "notes": "- **Intuition**: Track indices in queue removing from front when larger number enters window.\n- **Implementation**: Initialize deque and ans. Initialize left and right pointers to zero. Iterate while `r < len(nums)`. While queue is not empty and value at the top of the queue is less than the current value at right, pop from the top of the queue. Add right to queue. If left is greater than the index at the back of the queue (out of the window), pop from left. If `r + 1 >= k` (i.e. we have gotten to the minimum window size), add value at the back of the queue to the answer and slide window (increment `l`). Always increment `r`.\n- **Complexity**: Time `O(n)`, Space `O(n)` (queue)\n",
        "published": true,
        "datetime": "2025-12-27T22:29:30Z"
    },
    "balanced-binary-tree": {
        "id": "balanced-binary-tree",
        "title": "110. Balanced Binary Tree",
        "directory": "110-balanced-binary-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree"
        ],
        "notes": "- **Intuition**: Calculate depth with sentinel `-1` when abs difference is greater than 1.\n- **Implementation**: Calculate depth with DFS using recursive function. Base case, node is `None`, return `0`. Recurse on left side and save into variable, if depth is `-1`, early return `-1`. Same thing on right side. Check if absolute difference is greater than 1, return `-1`. Otherwise, return `1 + max(left, right)`. In main function, call DFS on root and check if equals `-1` (not balanced).\n- **Complexity**: Time `O(n)`, Space `O(h)` (recursion)\n",
        "published": true,
        "datetime": "2026-01-02T22:58:23Z"
    },
    "same-tree": {
        "id": "same-tree",
        "title": "100. Same Tree",
        "directory": "100-same-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "- **Intuition**: Both sides should be the same while iterating down together.\n- **Implementation**: Recursive DFS. Base case, `p` and `q` are null, return true. Otherwise, if `p` and `q` are not null and values are the same, return checking if both `p.left` and `q.left` are the same AND `p.right` and `q.right` are the same (recursive call). Otherwise, return false.\n- **Complexity**: Time `O(n)`, Space `O(h)` (recursive)\n",
        "published": true,
        "datetime": "2026-01-03T07:12:18Z"
    },
    "subtree-of-another-tree": {
        "id": "subtree-of-another-tree",
        "title": "572. Subtree of Another Tree",
        "directory": "572-subtree-of-another-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "- **Intuition**: Check if either left or right subtree is the same as subRoot recursively (DFS).\n- **Implementation**: Use DFS. Implement a function to check a if a two tree roots are the same using DFS (see solution). In the main function, if `subRoot` is None, early return `True`. If `root` is None, early return False. Check if `root` is the same as `subRoot` return True. Recursively call isSubtree on left and subroot OR right and subRoot. \n- **Edge-cases**: Remember the none checks on root and subRoot\n- **Complexity**: Time `O(n)` (DFS), Space `O(n)` (recursion)\n",
        "published": true,
        "datetime": "2026-01-12T19:01:22Z"
    },
    "lowest-common-ancestor-of-a-binary-search-tree": {
        "id": "lowest-common-ancestor-of-a-binary-search-tree",
        "title": "235. Lowest Common Ancestor of a Binary Search Tree",
        "directory": "235-lowest-common-ancestor-of-a-binary-search-tree",
        "difficulty": "Medium",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "- **Intuition**: Nodes of a BST will have values strictly smaller on the left and strictly larger on the right. LCA will be the split point.\n- **Implementation**: To solve iteratively (no recursion call stack, better space), initialize curr to root. Iterate while curr is not None. Check if p and q are both greater than the current value, that means the nodes are in the right side (larger side). Else if check if p and q are both smaller than the current value, that means the nodes in the left side (smaller side). Else, we have found the divergence point, LCA, return curr.\n- **Edge-cases**: Don't need to worry about the edge cases of root, p and q being null because valid input will be defined for all of these.\n- **Complexity**: Time `O(h)` (height of tree), Spce `O(1)`\n",
        "published": true,
        "datetime": "2026-01-12T19:58:25Z"
    },
    "max-level-party-invites": {
        "id": "max-level-party-invites",
        "title": "Max Level Party Invites",
        "directory": "max-level-party-invites",
        "difficulty": "Hard",
        "tags": [
            "graph",
            "dp",
            "dfs"
        ],
        "notes": "- **Intuition**: Tree problem with multiple trees. Compute the sum if we choose to invite or a skip a certain node.\n- **Implementation**: Start off by creating the adjacency list for the potentially disconnected trees. At the same time, create an array to mark nodes that have parents so we can only process roots for DFS. Create the DFS function in which we will compute the sum if we choose to invite a node and if we choose to skip that node. Also create dp/memoization map to ensure we only process each node once, early returning from DFS if we have already processed that node. In the DFS function, initialize the invite value for that node to be the level of that node from the `levels` array and the skip value to be 0. Iterate over the children (reports) from the adjacency list, for each child call dfs on it to get its invite and skip value. Add the skip value for the child to the invite value for the current node because if we choose to invite the current node, we have to skip its reports. For the skip value, we can take the max of the invite and skip value for the child because either works, we just want the max. Save the value in the dp/memoization map and return. After this, we iterate over all the roots (for the example cases, there is only one root but for generic cases, there could be multiple). Calculate the invite and skip values for each node and take the max of them forthe answer.\n- **Complexity**: Time `O(n)` (each node is only processed once due to the DP and DFS), Space `O(n)` (adjacency, memoization)\n",
        "published": true,
        "datetime": "2026-01-13T03:15:05Z"
    },
    "minimum-lock-turns": {
        "id": "minimum-lock-turns",
        "title": "Minimum Lock Turns",
        "directory": "minimum-lock-turns",
        "difficulty": "Medium",
        "tags": [
            "graph",
            "bfs"
        ],
        "notes": "- **Intuition**: Can be treated like a graph, traverse with BFS to find shortest path.\n- **Implementation**: Write a function to compute all neighbours of given combo (8 possible neighbours, 1 up and 1 down for each number). Create a set for the blocked combos and create a queue that is initialized with the start combo and 0 (number of turns) as a tuple. Also created a visited map initialized with the start combo. Iterate while q is not empty, popleft the current combo and the number of turns. Iterate over all the neighbours of that combo, if the neighbor is already visited or in the blocked combos, continue. If the neighbour is the target, return `turns + 1` as the answer. Otherwise, add the neighbour and `turns + 1` to the queue. If queue finishes, no possible turns can get to the target, return -1.\n- **Edge-cases**: Check before BFS if start is equal to target, return 0. Also check if start is in the blocked combos, return -1 (cannot go anywhere).\n- **Complexity**: Time `O(V)` where `V` is the number of possible states (10^4), Space `O(V)`\n",
        "published": true,
        "datetime": "2026-01-13T05:23:25Z"
    },
    "rummy-card-game": {
        "id": "rummy-card-game",
        "title": "Rummy Card Game",
        "directory": "rummy-card-game",
        "difficulty": "Hard",
        "tags": [
            "sliding-window",
            "math"
        ],
        "notes": "- **Intuition**: Group cards by rank and suit and then generate sets from same rank cards and sets from same suit cards.\n- **Implementation**: Start off by grouping cards by rank and suit in hash maps. For the sets, iterate over the rank map and ignore any ranks that have fewer than 3 cards. If they have >= 3 cards, iterate from 3 to the length of the cards + 1 and genrate combinations of those cards for each iteration. 3, 4, 5, so on. add that to result. For the sets, iterate over the suit map, ignore suits that have fewer than 3 cards. Extract the cards and sort them by suit. Iterate through and generate segments of consecutive cards. If you get to a point that it no longer consecutive, check if the current segments is greater than 3 and slide window across of size 3+, adding to result. Then, reset the segments to the current value to continue. At the end, there may be one more segment left so do the same.\n- **Complexity**: Time `O(n^2)` (because of the set algo, very small n so ok), Space `O(n^2)`\n",
        "published": true,
        "datetime": "2026-01-13T07:01:53Z"
    },
    "skyscraper-furthest-distance": {
        "id": "skyscraper-furthest-distance",
        "title": "Skyscraper Furthest Distance",
        "directory": "skyscraper-furthest-distance",
        "difficulty": "Medium",
        "tags": [
            "heap"
        ],
        "notes": "- **Intuition**: We want to save spring use only for the largest jumps.\n- **Implementation**: Use a max heap. Iterate through pairs, calculate the difference, if less than or equal to zero, free move, continue. Otherwise, assume we will use sandbags and decrement the sandbags. Add the difference to the max heap. If the sandbags value goes below zero, we need to use springs instead if we have them, if springs equals zero here, early return the index we are currently at. This handles the case of either springs being already used or not having any springs at all. If springs are not zero, decrement the springs value and add the value at the top of the max heap back to the sandbags. Effectively, this converts the largest jump we've seen to use a spring instead of sandbags.\n- **Edge-cases**: Rememeber Python uses min heap so we just negate the values to make it into a max heap.\n- **Complexity**: Time `O(n log n)` heap push and pop is `O(log n)`, Space `O(n)` (heap)\n",
        "published": true,
        "datetime": "2026-01-13T20:11:29Z"
    },
    "open-the-lock": {
        "id": "open-the-lock",
        "title": "752. Open the Lock",
        "directory": "752-open-the-lock",
        "difficulty": "Medium",
        "tags": [
            "graph",
            "bfs"
        ],
        "notes": "- **Intuition**: Can be treated like a graph with each state having 8 neighbours (turn each wheel up or down).\n- **Implementation**: Use BFS to find shortest path. Create a function to generate neighbours given a combo, should genrate 8 neighbours, turn each wheel up and down (use mod 10 to keep in bounds). Create a queue that is initialized with the start combo (`\"0000\"`) and 0 as the number of turns. Also create a map to keep track of the visited states. While the q has elements, pop left from the queue, iterate over the neighbours, if the neighbour is already visited or is in the deadends, continue. If the neighbour is equal to the target, return `turns + 1`, otherwise add the neighbour and turns + 1 to the queue and to the visited set.\n- **Complexity**: Time `O(V)` where `V` is the number of states (10^4), Space `O(V)`\n",
        "published": true,
        "datetime": "2026-01-13T20:51:21Z"
    },
    "furthest-building-you-can-reach": {
        "id": "furthest-building-you-can-reach",
        "title": "1642. Furthest Building You Can Reach",
        "directory": "1642-furthest-building-you-can-reach",
        "difficulty": "Medium",
        "tags": [
            "heap"
        ],
        "notes": "- **Intuition**: Use ladders for the largest jumps.\n- **Implementation**: Use a max heap. Iterate over pairs and calculate difference. If difference <= 0, continue. Otherwise, assume we will use bricks and decrement the bricks by the difference. Add the difference to the max heap. If the bricks go below 0, we must use a ladder. If ladders are equal to zero here, return the current index. Otherwise, decrement ladders and add back the max value in the heap to the bricks (effectively switching the largest jump we've seen to ladders instead of bricks). If iteration completes, return the last index.\n- **Complexity**: Time `O(n log n)`, Space `O(n)` (heap)\n",
        "published": true,
        "datetime": "2026-01-13T21:03:19Z"
    },
    "1730-shortest-path-to-get-food": {
        "id": "1730-shortest-path-to-get-food",
        "title": "1730. Shortest Path To Get Food",
        "directory": "1730-shortest-path-to-get-food",
        "difficulty": "Medium",
        "tags": [
            "graph",
            "bfs"
        ],
        "notes": "- **Intuition**: Basic graph shortest distance problem, use BFS.\n- **Implementation**: Use BFS to find the shortest path. Start by finding the coordinate of the start position. Add to queue tuple with 0 for the path length. Also add start to visited set. Iterate while queue is not empty, pop from the queue and iterate over the neighbours, if the neighbour is already visited or is blocked, continue. Otherwise, check if the neighbour is a food and return current path length + 1. Otherwise add the neighbour to visited and the queue with path + 1. If iteration completes, return -1.\n- **Complexity**: Time `O(m * n)`, Space `O(m * n)`\n",
        "published": true,
        "datetime": "2026-01-13T23:04:22Z"
    }
}