{
    "two-sum": {
        "id": "two-sum",
        "title": "1. Two Sum",
        "directory": "1-two-sum",
        "difficulty": "Easy",
        "tags": [
            "hashmap",
            "math"
        ],
        "notes": "- **Intuition**: To find a valid answer we simply need to find if the complement (`target - curr`) exists in the array\n- **Implementation**: Use a hashmap to store numbers with their indices (allow overwrites because duplicates are not allowed), check if the complement exists in the map and is not the same number, return\n- **Edge-cases**: Ensure that you check the indices are not the same when returning (i.e. `map[complement] != i`)\n",
        "published": true
    },
    "contains-duplicate": {
        "id": "contains-duplicate",
        "title": "217. Contains Duplicate",
        "directory": "217-contains-duplicate",
        "difficulty": "Easy",
        "tags": [
            "hashmap"
        ],
        "notes": "- **Intuition**: Need to check if a given number exists in the array\n- **Implementation**: Use a hashmap, check if the current number is in the map, return True if found, otherwise add to map, return False at the end of loop (no duplicates found)\n",
        "published": true
    },
    "valid-anagram": {
        "id": "valid-anagram",
        "title": "242. Valid Anagram",
        "directory": "242-valid-anagram",
        "difficulty": "Easy",
        "tags": [
            "hashmap",
            "frequency"
        ],
        "notes": "- **Intuition**: An anagram means the strings have the same frequency of letters, i.e. abc is anagram of bac or cab, etc.\n- **Implementation**: Since only lowercase alphabet, increment in 26 value array at each character index (i.e. a = index 0, b = index 1, etc.) for `s` and decrement for `t`, if frequency array is zero, return True, otherwise False\n",
        "published": true
    },
    "group-anagrams": {
        "id": "group-anagrams",
        "title": "49. Group Anagrams",
        "directory": "49-group-anagrams",
        "difficulty": "Medium",
        "tags": [
            "hashmap",
            "frequency"
        ],
        "notes": "- **Intuition**: Every \"group\" of anagrams will have the same frequency table (26 value array)\n- **Implementation**: Use a hashmap with the key being the frequency table and the value being the group of strings, iterate over each string, create the frequency table, check the map, add or create new entry in the map, finally take all the values from the map and flatten into a single result\n- **Edge-cases**: Python doesn't allow arbitrary values as keys, convert frequency table to comma-separated string\n",
        "published": true
    },
    "top-k-frequent-elements": {
        "id": "top-k-frequent-elements",
        "title": "347. Top K Frequent Elements",
        "directory": "347-top-k-frequent-elements",
        "difficulty": "Medium",
        "tags": [
            "hashmap",
            "frequency"
        ],
        "notes": "- **Intuition**: We can use an array that maps index to frequency (i.e. freq[1] = 2 means 2 has a frequency of 1), allowing us to formulate the answer in `O(n)` time\n- **Implementation**: Use a hashmap to count frequencies, iterate over hashmap and create our frequency array (length `n + 1`, 1-based indexing), iterate backwards over frequency array to create result\n- **Edge-cases**: Multiple elements can have the same frequency so frequency array should be an array of arrays, when iterating backwards go into arrays if needed\n",
        "published": true
    },
    "product-of-array-except-self": {
        "id": "product-of-array-except-self",
        "title": "238. Product of Array Except Self",
        "directory": "238-product-of-array-except-self",
        "difficulty": "Medium",
        "tags": [
            "math"
        ],
        "notes": "- **Intuition**: Use `prefix` and `suffix` arrays to calculate answer at each index. `prefix` is the product of all elements before `i` and `suffix` is the product of all elements after `i`.\n- **Implementation**: Initialize `prefix` with `1` (before `i = 0` is just 1), iterate from `1 to n`, `prefix[i] = nums[i - 1] * prefix[i - 1]`. Initialize `suffix` with `suffix[-1] = 1` (after the end of the array, just 1 left), iterate backwards `n-2 to 0`, `suffix[i] = nums[i + 1] * suffix[i + 1]`. Answer is `ans[i] = prefix[i] * suffix[i]`\n",
        "published": true
    },
    "valid-sudoku": {
        "id": "valid-sudoku",
        "title": "36. Valid Sudoku",
        "directory": "36-valid-sudoku",
        "difficulty": "Medium",
        "tags": [
            "matrix"
        ],
        "notes": "- **Intuition**: Check each row, column and 3x3 subbox for duplicates essentially\n- **Implementation**: Use a hashmap to check for duplicates in each row, column and 3x3 subbox\n- **Edge-cases**: Figuring out the indexing of the 3x3 subbox is difficult. Do 4 nested loops, `box_row (0 to 3)`, `box_col (0 to 3)`, `row (0 to 3)`, `col (0 to 3)`, then we can access the specific value with `board[3 * box_row + row][3  * box_col + col]`\n",
        "published": true
    },
    "longest-consecutive-sequence": {
        "id": "longest-consecutive-sequence",
        "title": "128. Longest Consecutive Sequence",
        "directory": "128-longest-consecutive-sequence",
        "difficulty": "Medium",
        "tags": [
            "hashmap",
            "math"
        ],
        "notes": "- **Intuition**: The start of a sequence is when there IS a number exactly 1 greater than it in the array and NOT a number exactly 1 less than it. When a sequence start is found, iterate looking for the next values, keeping track of the max length\n- **Implementation**: Use hashmap to store all numbers for `O(1)` lookup, iterate and look for sequence start, iterate building the sequence and keep track of max\n- **Edge-cases**: In case of duplicates, we don't process the same sequence start multiple times. Initialize hashmap with all `False` values, when processing a sequence start, mark it as `True` to signify this sequence start is already processed and don't process that sequence start again\n",
        "published": true
    }
}