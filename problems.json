{
    "two-sum": {
        "id": "two-sum",
        "title": "1. Two Sum",
        "directory": "1-two-sum",
        "difficulty": "Easy",
        "tags": [
            "hashmap",
            "math"
        ],
        "notes": "## Intuition\nThe key insight is that for any number in the array, we need to find if its complement (target minus that number) exists elsewhere in the array. Rather than searching for the complement with nested loops, we can use a hashmap for constant-time lookups.\n\n## Implementation\nFirst, populate a hashmap with each number as the key and its index as the value. Since the problem guarantees exactly one solution with distinct indices, we can safely overwrite duplicate values. Then iterate through the array again, computing the complement for each number and checking if it exists in the map.\n\n## Edge-cases\nWhen checking for the complement in the map, ensure the found index is different from the current index. This prevents returning the same element twice (e.g., if target is 6 and we have a 3, we shouldn't return [0, 0]).\n\n## Complexity\nTime `O(n)` for two passes through the array. Space `O(n)` for the hashmap storing all elements.\n",
        "published": true,
        "datetime": "2025-12-22T09:18:55Z"
    },
    "contains-duplicate": {
        "id": "contains-duplicate",
        "title": "217. Contains Duplicate",
        "directory": "217-contains-duplicate",
        "difficulty": "Easy",
        "tags": [
            "hashmap"
        ],
        "notes": "## Intuition\nTo detect duplicates efficiently, we need a way to quickly check if we've seen a number before. A hashmap provides O(1) lookups, making it ideal for tracking previously encountered values.\n\n## Implementation\nIterate through the array, checking each number against a hashmap. If the number already exists in the map, we've found a duplicate\u2014return True immediately. Otherwise, add the number to the map and continue. If the loop completes without finding any duplicates, return False.\n\n## Edge-cases\nNo special edge cases beyond empty arrays, which would simply return False since there's nothing to duplicate.\n\n## Complexity\nTime `O(n)` for a single pass through the array. Space `O(n)` for the hashmap in the worst case where all elements are unique.\n",
        "published": true,
        "datetime": "2025-12-22T09:19:02Z"
    },
    "valid-anagram": {
        "id": "valid-anagram",
        "title": "242. Valid Anagram",
        "directory": "242-valid-anagram",
        "difficulty": "Easy",
        "tags": [
            "hashmap",
            "frequency"
        ],
        "notes": "## Intuition\nTwo strings are anagrams if they contain exactly the same characters with the same frequencies. Rather than sorting both strings and comparing, we can use a frequency count approach that's more efficient.\n\n## Implementation\nSince the input only contains lowercase English letters, use a fixed-size array of 26 elements as a frequency counter. Increment the count for each character in the first string, then decrement for each character in the second string. If the strings are anagrams, all counts will return to zero.\n\n## Edge-cases\nStrings of different lengths cannot be anagrams, though this is implicitly handled by the frequency counting approach.\n\n## Complexity\nTime `O(n)` for iterating through both strings. Space `O(1)` since the frequency array is always 26 elements regardless of input size.\n",
        "published": true,
        "datetime": "2025-12-22T09:19:12Z"
    },
    "group-anagrams": {
        "id": "group-anagrams",
        "title": "49. Group Anagrams",
        "directory": "49-group-anagrams",
        "difficulty": "Medium",
        "tags": [
            "hashmap",
            "frequency"
        ],
        "notes": "## Intuition\nAll anagrams share the same character frequency distribution. If we can create a canonical representation of this frequency, we can use it as a key to group anagrams together in a hashmap.\n\n## Implementation\nFor each string, build a frequency table (26-element array for lowercase letters). Use this frequency table as a hashmap key, with the value being a list of strings that share that frequency signature. After processing all strings, return the hashmap values as the grouped anagrams.\n\n## Edge-cases\nPython dictionaries don't allow lists as keys, so convert the frequency table to a comma-separated string (e.g., \"1,0,1,0,...\") to use as the key.\n\n## Complexity\nTime `O(n * k)` where n is the number of strings and k is the maximum string length. Space `O(n)` for the hashmap storing all strings.\n",
        "published": true,
        "datetime": "2025-12-22T09:19:22Z"
    },
    "top-k-frequent-elements": {
        "id": "top-k-frequent-elements",
        "title": "347. Top K Frequent Elements",
        "directory": "347-top-k-frequent-elements",
        "difficulty": "Medium",
        "tags": [
            "hashmap",
            "frequency"
        ],
        "notes": "## Intuition\nInstead of sorting by frequency (which would be O(n log n)), we can use bucket sort. Since the maximum frequency of any element is bounded by the array length n, we can create an array where the index represents the frequency and the value is a list of elements with that frequency.\n\n## Implementation\nFirst, count frequencies using a hashmap. Then create a bucket array of size n+1, where each index i contains elements that appear exactly i times. Finally, iterate backwards from the highest frequency bucket, collecting elements until we have k items.\n\n## Edge-cases\nMultiple elements can share the same frequency, so each bucket must be a list rather than a single value. When collecting results, iterate through each bucket's contents before moving to the next.\n\n## Complexity\nTime `O(n)` for counting and bucket distribution. Space `O(n)` for the frequency map and bucket array.\n",
        "published": true,
        "datetime": "2025-12-22T09:19:31Z"
    },
    "product-of-array-except-self": {
        "id": "product-of-array-except-self",
        "title": "238. Product of Array Except Self",
        "directory": "238-product-of-array-except-self",
        "difficulty": "Medium",
        "tags": [
            "math"
        ],
        "notes": "## Intuition\nWithout using division, we need another way to compute the product of all elements except the current one. The key observation is that for any index i, the answer is the product of all elements to its left multiplied by the product of all elements to its right.\n\n## Implementation\nBuild two arrays: `prefix` where `prefix[i]` holds the product of all elements before index i, and `suffix` where `suffix[i]` holds the product of all elements after index i. Initialize `prefix[0] = 1` (nothing before the first element) and `suffix[n-1] = 1` (nothing after the last element). The answer at each index is simply `prefix[i] * suffix[i]`.\n\n## Edge-cases\nNo special edge cases since the problem guarantees the product will fit in a 32-bit integer.\n\n## Complexity\nTime `O(n)` for three linear passes (prefix, suffix, and result). Space `O(n)` for the prefix and suffix arrays.\n",
        "published": true,
        "datetime": "2025-12-22T09:19:39Z"
    },
    "valid-sudoku": {
        "id": "valid-sudoku",
        "title": "36. Valid Sudoku",
        "directory": "36-valid-sudoku",
        "difficulty": "Medium",
        "tags": [
            "matrix"
        ],
        "notes": "## Intuition\nA valid Sudoku board must have no duplicate digits in any row, column, or 3x3 subbox. We need to validate all three constraints independently.\n\n## Implementation\nUse a hashmap to track seen digits for each constraint. Iterate through rows checking for duplicates, then columns, then each 3x3 subbox. For subboxes, use nested loops with the outer loops selecting which box (0-2 for both row and column) and inner loops iterating within that box.\n\n## Edge-cases\nThe tricky part is indexing into 3x3 subboxes. With box indices `brow` and `bcol` (0-2) and local indices `row` and `col` (0-2), access the cell at `board[3 * brow + row][3 * bcol + col]`.\n\n## Complexity\nTime `O(1)` since the board is always 9x9. Space `O(1)` since the hashmaps hold at most 9 elements each.\n",
        "published": true,
        "datetime": "2025-12-22T09:19:52Z"
    },
    "longest-consecutive-sequence": {
        "id": "longest-consecutive-sequence",
        "title": "128. Longest Consecutive Sequence",
        "directory": "128-longest-consecutive-sequence",
        "difficulty": "Medium",
        "tags": [
            "hashmap",
            "math"
        ],
        "notes": "## Intuition\nTo achieve O(n) time, we can't sort. Instead, identify sequence starting points\u2014numbers that have no predecessor (n-1 not in array). From each starting point, count how far the sequence extends.\n\n## Implementation\nStore all numbers in a hashset for O(1) lookups. Iterate through the array and for each number, check if it's a sequence start (n-1 doesn't exist). If it is, count consecutive numbers starting from it by repeatedly checking for n+1, n+2, etc. Track the maximum sequence length found.\n\n## Edge-cases\nDuplicates can cause the same sequence to be processed multiple times. Mark sequence starts as processed after handling them to avoid redundant work.\n\n## Complexity\nTime `O(n)` because each number is visited at most twice (once in the main loop, once when extending a sequence). Space `O(n)` for the hashset.\n",
        "published": true,
        "datetime": "2025-12-22T09:20:01Z"
    },
    "valid-palindrome": {
        "id": "valid-palindrome",
        "title": "125. Valid Palindrome",
        "directory": "125-valid-palindrome",
        "difficulty": "Easy",
        "tags": [
            "two-pointers",
            "string"
        ],
        "notes": "## Intuition\nA palindrome reads the same forwards and backwards. Using two pointers starting from opposite ends and moving toward the center, we can verify this property in a single pass.\n\n## Implementation\nInitialize left pointer at the start and right pointer at the end. Move both toward the center, comparing characters. If they don't match, it's not a palindrome. Continue until the pointers meet or cross.\n\n## Edge-cases\nThe input may contain non-alphanumeric characters and mixed case. Convert everything to lowercase and skip over any non-alphanumeric characters during traversal.\n\n## Complexity\nTime `O(n)` for a single pass through the string. Space `O(1)` using only two pointers.\n",
        "published": true,
        "datetime": "2025-12-22T09:20:13Z"
    },
    "two-sum-ii-input-array-is-sorted": {
        "id": "two-sum-ii-input-array-is-sorted",
        "title": "167. Two Sum II - Input Array Is Sorted",
        "directory": "167-two-sum-ii-input-array-is-sorted",
        "difficulty": "Medium",
        "tags": [
            "two-pointers",
            "binary-search"
        ],
        "notes": "## Intuition\nThe sorted property allows us to use binary search. For each number, its complement (target - current) must be somewhere to its right (since using the same element twice isn't allowed and left elements are smaller).\n\n## Implementation\nFor each element at index i, compute the complement and binary search for it in the subarray from i+1 to the end. If found, return both indices (1-indexed as per the problem). If not found, continue to the next element.\n\n## Edge-cases\nRemember to return 1-indexed results as required by the problem.\n\n## Complexity\nTime `O(n log n)` for n binary searches. Space `O(1)` using only pointers.\n",
        "published": true,
        "datetime": "2025-12-22T09:20:24Z"
    },
    "3sum": {
        "id": "3sum",
        "title": "15. 3Sum",
        "directory": "15-3sum",
        "difficulty": "Medium",
        "tags": [
            "binary-search",
            "two-pointers"
        ],
        "notes": "## Intuition\nThis extends the Two Sum II pattern. Sort the array first, then for each element, use two pointers to find pairs in the remaining array that sum to the negative of that element (making the total zero).\n\n## Implementation\nSort the array. For each index i, set left pointer to i+1 and right pointer to the end. If the sum of all three equals zero, record the triplet. If the sum is too large, move right pointer left; if too small, move left pointer right.\n\n## Edge-cases\nTo avoid duplicate triplets, skip over consecutive identical values for the outer loop index. Similarly, after finding a valid triplet, skip over duplicates for both left and right pointers before continuing the search.\n\n## Complexity\nTime `O(n^2)` for sorting plus the nested two-pointer search. Space `O(1)` excluding the output array.\n",
        "published": true,
        "datetime": "2025-12-22T09:20:38Z"
    },
    "container-with-most-water": {
        "id": "container-with-most-water",
        "title": "11. Container With Most Water",
        "directory": "11-container-with-most-water",
        "difficulty": "Medium",
        "tags": [
            "two-pointers",
            "math"
        ],
        "notes": "## Intuition\nThe area is determined by width (distance between lines) and height (the shorter of the two lines). Starting with maximum width (pointers at both ends), we can only potentially increase area by finding a taller line, so always move the pointer pointing to the shorter line inward.\n\n## Implementation\nPlace left and right pointers at the array ends. Calculate area using the minimum height times the width. Move the pointer at the shorter line toward the center, as keeping it could only decrease the area. Track the maximum area seen.\n\n## Edge-cases\nWhen both heights are equal, it doesn't matter which pointer moves since neither can form a larger area with the current other side.\n\n## Complexity\nTime `O(n)` for a single pass with two pointers. Space `O(1)` using only pointers.\n",
        "published": true,
        "datetime": "2025-12-22T09:20:47Z"
    },
    "valid-parentheses": {
        "id": "valid-parentheses",
        "title": "20. Valid Parentheses",
        "directory": "20-valid-parentheses",
        "difficulty": "Easy",
        "tags": [
            "stack"
        ],
        "notes": "## Intuition\nBrackets must be closed in the reverse order they were opened (LIFO). A stack naturally models this\u2014push opening brackets and pop when we see their matching closing brackets.\n\n## Implementation\nCreate a map from opening to closing brackets. When encountering an opening bracket, push its expected closing bracket onto the stack. When encountering a closing bracket, check if it matches the stack's top. If it matches, pop and continue; if not, the string is invalid.\n\n## Edge-cases\nCheck for two conditions: if a closing bracket appears when the stack is empty (no matching opener), and if the stack is non-empty after processing (unclosed brackets remain).\n\n## Complexity\nTime `O(n)` for a single pass through the string. Space `O(n)` for the stack in the worst case of all opening brackets.\n",
        "published": true,
        "datetime": "2025-12-22T09:20:52Z"
    },
    "min-stack": {
        "id": "min-stack",
        "title": "155. Min Stack",
        "directory": "155-min-stack",
        "difficulty": "Medium",
        "tags": [
            "stack"
        ],
        "notes": "## Intuition\nTo retrieve the minimum in O(1), maintain a secondary stack that tracks the minimum value at each \"level\" of the main stack. The min stack's top always reflects the current minimum.\n\n## Implementation\nUse two stacks: a main stack for values and a min stack for minimums. On push, always add to the main stack. If the value is less than or equal to the current minimum (or the stack is empty), also push to the min stack. On pop, remove from the main stack, and if the popped value equals the min stack's top, also pop from the min stack.\n\n## Edge-cases\nPush to the min stack when the value equals the current minimum, not just when it's strictly less. This handles duplicate minimum values correctly.\n\n## Complexity\nTime `O(1)` for all operations. Space `O(n)` for both stacks in the worst case.\n",
        "published": true,
        "datetime": "2025-12-22T09:20:59Z"
    },
    "evaluate-reverse-polish-notation": {
        "id": "evaluate-reverse-polish-notation",
        "title": "150. Evaluate Reverse Polish Notation",
        "directory": "150-evaluate-reverse-polish-notation",
        "difficulty": "Medium",
        "tags": [
            "stack",
            "math"
        ],
        "notes": "## Intuition\nIn Reverse Polish Notation, operators come after their operands. A stack naturally handles this\u2014operands are pushed, and when an operator appears, we pop the last two operands, apply the operation, and push the result.\n\n## Implementation\nIterate through tokens. If the token is a number, push it onto the stack. If it's an operator, pop two values, apply the operation (with the second popped value as the left operand), and push the result. After processing all tokens, the stack contains one element: the answer.\n\n## Edge-cases\nFor division and subtraction, operand order matters. The first pop gives the right operand, the second pop gives the left. Also, Python's `//` operator doesn't truncate toward zero for negative numbers\u2014use `int(a / b)` instead.\n\n## Complexity\nTime `O(n)` for a single pass through tokens. Space `O(n)` for the stack.\n",
        "published": true,
        "datetime": "2025-12-22T09:21:09Z"
    },
    "generate-parentheses": {
        "id": "generate-parentheses",
        "title": "22. Generate Parentheses",
        "directory": "22-generate-parentheses",
        "difficulty": "Medium",
        "tags": [
            "stack",
            "recursion"
        ],
        "notes": "## Intuition\nGenerate all valid combinations by building strings character by character, only adding characters that keep the string valid. We can add an open parenthesis if we haven't used all n, and a close parenthesis only if it doesn't exceed the number of opens.\n\n## Implementation\nUse backtracking with a recursive function tracking the count of open and close parentheses used. Base case: when both counts equal n, add the current string to results. Otherwise, try adding '(' if opens < n, then backtrack. Try adding ')' if closes < opens, then backtrack.\n\n## Edge-cases\nNo special edge cases since the constraints ensure valid input (n >= 1).\n\n## Complexity\nTime is related to the n-th Catalan number: `O(4^n / sqrt(n))`. Space `O(n)` for the recursion depth and current string being built.\n",
        "published": true,
        "datetime": "2025-12-22T09:21:18Z"
    },
    "daily-temperatures": {
        "id": "daily-temperatures",
        "title": "739. Daily Temperatures",
        "directory": "739-daily-temperatures",
        "difficulty": "Medium",
        "tags": [
            "stack"
        ],
        "notes": "## Intuition\nFor each day, we need to find the next warmer day. A monotonic decreasing stack helps\u2014when we find a warmer temperature, it's warmer than all temperatures currently on the stack, so we can pop and compute distances.\n\n## Implementation\nInitialize a result array with zeros (default for days with no warmer future day). Use a stack storing (temperature, index) pairs. For each day, while the stack is non-empty and the current temperature is warmer than the stack's top, pop and record the distance in the result. Then push the current day onto the stack.\n\n## Edge-cases\nDays remaining on the stack after processing have no warmer future day, which is correctly represented by the initialized zeros.\n\n## Complexity\nTime `O(n)` since each element is pushed and popped at most once. Space `O(n)` for the stack.\n",
        "published": true,
        "datetime": "2025-12-22T09:21:24Z"
    },
    "car-fleet": {
        "id": "car-fleet",
        "title": "853. Car Fleet",
        "directory": "853-car-fleet",
        "difficulty": "Medium",
        "tags": [
            "stack",
            "math"
        ],
        "notes": "## Intuition\nCars can only form fleets by catching up to slower cars ahead. Process cars from closest to target backward\u2014if a car behind arrives at the same time or earlier than the car ahead, they form a fleet traveling at the slower car's speed.\n\n## Implementation\nCombine position and speed, then sort by position in descending order (closest to target first). Use a stack to track arrival times of fleet leaders. For each car, calculate its time to reach the target. If this time exceeds the stack's top (meaning it can't catch the fleet ahead), it becomes a new fleet leader\u2014push it onto the stack.\n\n## Edge-cases\nCars at the same position with different speeds should be handled by the sorting; the faster one would catch up instantly.\n\n## Complexity\nTime `O(n log n)` dominated by sorting. Space `O(n)` for the stack.\n",
        "published": true,
        "datetime": "2025-12-22T09:21:32Z"
    },
    "largest-rectangle-in-histogram": {
        "id": "largest-rectangle-in-histogram",
        "title": "84. Largest Rectangle in Histogram",
        "directory": "84-largest-rectangle-in-histogram",
        "difficulty": "Hard",
        "tags": [
            "stack",
            "math"
        ],
        "notes": "## Intuition\nFor each bar, we want to find how far left and right it can extend as the shortest bar. A monotonic increasing stack helps\u2014when we encounter a shorter bar, all taller bars on the stack can no longer extend right, so we calculate their areas.\n\n## Implementation\nUse a stack storing indices of bars in increasing height order. Iterate through the histogram plus one extra index (with height 0 to flush the stack). When the current height is less than the stack's top, pop and calculate area using the popped height and the width between the current index and the new stack top.\n\n## Edge-cases\nWhen the stack becomes empty after popping, the left boundary extends to index -1 (the popped bar spans from the start). Handle this by using -1 as the left index.\n\n## Complexity\nTime `O(n)` since each bar is pushed and popped at most once. Space `O(n)` for the stack.\n",
        "published": true,
        "datetime": "2025-12-22T09:21:38Z"
    },
    "binary-search": {
        "id": "binary-search",
        "title": "704. Binary Search",
        "directory": "704-binary-search",
        "difficulty": "Easy",
        "tags": [
            "binary-search"
        ],
        "notes": "## Intuition\nIn a sorted array, comparing the target with the middle element tells us which half to search next. By repeatedly halving the search space, we find the target in logarithmic time.\n\n## Implementation\nSet left and right pointers to the array bounds. While left <= right, compute the midpoint. If the middle element equals the target, return its index. If the middle is less than the target, search the right half by setting left = mid + 1. Otherwise, search the left half by setting right = mid - 1.\n\n## Edge-cases\nThe loop condition must be left <= right (not just <) to handle the case where the target is at the last remaining position when left equals right.\n\n## Complexity\nTime `O(log n)` as the search space halves each iteration. Space `O(1)` using only pointers.\n",
        "published": true,
        "datetime": "2025-12-22T09:21:50Z"
    },
    "search-a-2d-matrix": {
        "id": "search-a-2d-matrix",
        "title": "74. Search a 2D Matrix",
        "directory": "74-search-a-2d-matrix",
        "difficulty": "Medium",
        "tags": [
            "binary-search",
            "matrix"
        ],
        "notes": "## Intuition\nThe matrix is sorted both row-wise and column-wise, with each row's first element greater than the previous row's last element. This allows two binary searches: first find the correct row, then search within that row.\n\n## Implementation\nBinary search on rows using top and bottom pointers. A row is correct if the target falls between its first and last elements. Once found, perform standard binary search within that row. If the row search completes without finding a valid row, the target doesn't exist.\n\n## Edge-cases\nIf the row containing the target range is found but the inner binary search fails, return False immediately\u2014don't continue searching other rows.\n\n## Complexity\nTime `O(log m + log n)` for binary search on rows then columns. Space `O(1)` using only pointers.\n",
        "published": true,
        "datetime": "2025-12-22T09:22:00Z"
    },
    "koko-eating-bananas": {
        "id": "koko-eating-bananas",
        "title": "875. Koko Eating Bananas",
        "directory": "875-koko-eating-bananas",
        "difficulty": "Medium",
        "tags": [
            "binary-search",
            "math"
        ],
        "notes": "## Intuition\nWe're searching for the minimum eating speed that allows finishing within h hours. The answer lies between 1 and max(piles). Binary search works because if speed k works, all speeds > k also work\u2014the answer space is monotonic.\n\n## Implementation\nBinary search on speed from 1 to max(piles). For each candidate speed, calculate total hours needed (sum of ceil(pile/speed) for each pile). If hours exceed h, we need faster eating\u2014search higher. Otherwise, search lower to find the minimum valid speed.\n\n## Edge-cases\nUse ceiling division when calculating hours per pile since Koko can't eat a fractional pile and must spend at least one hour on any non-empty pile.\n\n## Complexity\nTime `O(n log m)` where n is number of piles and m is max pile size. Space `O(1)`.\n",
        "published": true,
        "datetime": "2025-12-22T09:22:08Z"
    },
    "find-minimum-in-rotated-sorted-array": {
        "id": "find-minimum-in-rotated-sorted-array",
        "title": "153. Find Minimum in Rotated Sorted Array",
        "directory": "153-find-minimum-in-rotated-sorted-array",
        "difficulty": "Medium",
        "tags": [
            "binary-search"
        ],
        "notes": "## Intuition\nIn a rotated sorted array, the minimum is the only element smaller than both its neighbors (the rotation pivot point). Binary search can find it by always moving toward the unsorted half.\n\n## Implementation\nCompare the middle element with the rightmost element. If mid > right, the minimum must be in the right half (that's where the rotation occurred). Otherwise, it's in the left half including mid. The minimum is found when an element is smaller than both neighbors.\n\n## Edge-cases\nHandle boundary conditions at index 0 and n-1 when checking neighbors. If mid is at these boundaries, only check the valid neighbor.\n\n## Complexity\nTime `O(log n)` for binary search. Space `O(1)` using only pointers.\n",
        "published": true,
        "datetime": "2025-12-22T09:22:15Z"
    },
    "search-in-rotated-sorted-array": {
        "id": "search-in-rotated-sorted-array",
        "title": "33. Search in Rotated Sorted Array",
        "directory": "33-search-in-rotated-sorted-array",
        "difficulty": "Medium",
        "tags": [
            "binary-search"
        ],
        "notes": "## Intuition\nFirst find the rotation pivot (minimum element), which divides the array into two sorted subarrays. Then determine which subarray contains the target and perform standard binary search on it.\n\n## Implementation\nUse the Find Minimum in Rotated Sorted Array algorithm to locate the pivot index. Then check if the target falls in the left sorted portion (0 to pivot-1) or the right sorted portion (pivot to end). Perform binary search on the appropriate half.\n\n## Edge-cases\nWhen determining which half contains the target, compare against both the first element and the element before the pivot to correctly identify the range.\n\n## Complexity\nTime `O(log n)` for finding the pivot plus searching. Space `O(1)` using only pointers.\n",
        "published": true,
        "datetime": "2025-12-22T09:22:23Z"
    },
    "best-time-to-buy-and-sell-stock": {
        "id": "best-time-to-buy-and-sell-stock",
        "title": "121. Best Time to Buy and Sell Stock",
        "directory": "121-best-time-to-buy-and-sell-stock",
        "difficulty": "Easy",
        "tags": [
            "sliding-window"
        ],
        "notes": "## Intuition\nWe need to find the maximum difference where the larger value comes after the smaller one. Track the minimum price seen so far and compute the potential profit at each step.\n\n## Implementation\nUse two pointers: buy (tracking the minimum price so far) and sell (current day). For each sell day, calculate profit. If positive, update max profit. If negative (current price is lower than buy price), move buy to the current position\u2014we found a better buying opportunity.\n\n## Edge-cases\nIf the array has one or zero elements, no transaction is possible\u2014return 0.\n\n## Complexity\nTime `O(n)` for a single pass. Space `O(1)` using only pointers and a max tracker.\n",
        "published": true,
        "datetime": "2025-12-22T09:22:31Z"
    },
    "longest-substring-without-repeating-characters": {
        "id": "longest-substring-without-repeating-characters",
        "title": "3. Longest Substring Without Repeating Characters",
        "directory": "3-longest-substring-without-repeating-characters",
        "difficulty": "Medium",
        "tags": [
            "sliding-window"
        ],
        "notes": "## Intuition\nUse a sliding window that expands right and contracts left whenever we encounter a duplicate. The window always represents a valid substring without repeating characters.\n\n## Implementation\nMaintain a set of characters in the current window. Expand the window by moving the right pointer. If the new character already exists in the set, shrink from the left by removing characters until the duplicate is gone. Track the maximum window size throughout.\n\n## Edge-cases\nWindow size is calculated as `r - l + 1` since both pointers are inclusive indices.\n\n## Complexity\nTime `O(n)` since each character is added and removed from the set at most once. Space `O(min(n, m))` where m is the character set size.\n",
        "published": true,
        "datetime": "2025-12-22T09:22:40Z"
    },
    "longest-repeating-character-replacement": {
        "id": "longest-repeating-character-replacement",
        "title": "424. Longest Repeating Character Replacement",
        "directory": "424-longest-repeating-character-replacement",
        "difficulty": "Medium",
        "tags": [
            "sliding-window"
        ],
        "notes": "## Intuition\nIn any window, the number of characters we need to replace equals the window length minus the count of the most frequent character. If this exceeds k, the window is invalid and must shrink.\n\n## Implementation\nUse a frequency array (26 elements) and track the maximum frequency seen. Expand the window right, updating frequencies. If `windowLength - maxFreq > k`, the window needs too many replacements\u2014shrink from the left. Track the maximum valid window length.\n\n## Edge-cases\nWindow size is `r - l + 1`. The maxFreq doesn't need to decrease when shrinking because we only care about finding larger valid windows, not maintaining exact counts.\n\n## Complexity\nTime `O(n)` for a single pass. Space `O(1)` since the frequency array is fixed at 26 elements.\n",
        "published": true,
        "datetime": "2025-12-22T09:22:51Z"
    },
    "permutation-in-string": {
        "id": "permutation-in-string",
        "title": "567. Permutation in String",
        "directory": "567-permutation-in-string",
        "difficulty": "Medium",
        "tags": [
            "sliding-window"
        ],
        "notes": "## Intuition\nA permutation of s1 has exactly the same character frequencies as s1. Slide a fixed-size window (length of s1) across s2 and check if the window's frequency matches s1's frequency.\n\n## Implementation\nBuild a frequency map from s1. Slide a window of the same size across s2: subtract entering characters and add leaving characters to the map. When all frequencies are zero, we've found a permutation. Use a single map\u2014increment for s1 chars, decrement for s2 window chars.\n\n## Edge-cases\nIf s1 is longer than s2, no permutation can exist\u2014return False immediately. Also check the final window position after the loop ends.\n\n## Complexity\nTime `O(n)` where n is the length of s2. Space `O(1)` since the frequency array is always 26 elements.\n",
        "published": true,
        "datetime": "2025-12-22T09:22:58Z"
    },
    "minimum-window-substring": {
        "id": "minimum-window-substring",
        "title": "76. Minimum Window Substring",
        "directory": "76-minimum-window-substring",
        "difficulty": "Hard",
        "tags": [
            "sliding-window"
        ],
        "notes": "## Intuition\nExpand the window until it contains all characters from t, then contract from the left to find the minimum valid window. Track required character frequencies and decrement as we include them in the window.\n\n## Implementation\nBuild a frequency map of characters needed from t. Expand right, decrementing frequencies for matched characters. When all frequencies are <= 0 (all requirements met), the window is valid\u2014record it if it's the smallest. Then shrink from the left, incrementing frequencies for removed characters, until the window becomes invalid again.\n\n## Edge-cases\nWhen expanding, update the frequency map after moving the pointer. When shrinking, update before moving. Initialize the result to empty string to distinguish \"not found\" from \"found empty.\"\n\n## Complexity\nTime `O(m + n)` where m is the length of s and n is the length of t. Space `O(n)` for the frequency map.\n",
        "published": true,
        "datetime": "2025-12-22T09:58:11Z"
    },
    "reverse-linked-list": {
        "id": "reverse-linked-list",
        "title": "206. Reverse Linked List",
        "directory": "206-reverse-linked-list",
        "difficulty": "Easy",
        "tags": [
            "linked-list"
        ],
        "notes": "## Intuition\nTo reverse a linked list in place, we need to reverse each node's next pointer to point to its previous node instead of its next node.\n\n## Implementation\nMaintain two pointers: `curr` (starting at head) and `prev` (starting at None). For each node, save its next pointer, reverse it to point to prev, then advance both pointers. When curr becomes None, prev points to the new head.\n\n## Edge-cases\nThe order of operations matters: save next before overwriting it, then update the link, then move pointers. An empty list (head is None) works correctly since the loop never executes.\n\n## Complexity\nTime `O(n)` for a single pass through the list. Space `O(1)` using only pointers.\n",
        "published": true,
        "datetime": "2025-12-22T22:43:29Z"
    },
    "merge-two-sorted-lists": {
        "id": "merge-two-sorted-lists",
        "title": "21. Merge Two Sorted Lists",
        "directory": "21-merge-two-sorted-lists",
        "difficulty": "Easy",
        "tags": [
            "linked-list"
        ],
        "notes": "## Intuition\nSince both lists are sorted, the smallest element is always at one of the two heads. Compare them, take the smaller one, and advance that list's pointer.\n\n## Implementation\nCreate a dummy node to simplify edge cases. Use a curr pointer starting at dummy. While both lists have nodes, compare their values, append the smaller one to curr, and advance the appropriate pointer. After one list is exhausted, append the remainder of the other list.\n\n## Edge-cases\nUsing a dummy node eliminates special handling for the result's head. One or both input lists might be empty, which the algorithm handles naturally.\n\n## Complexity\nTime `O(m + n)` visiting each node once. Space `O(1)` if we reuse existing nodes, or `O(m + n)` if creating new nodes.\n",
        "published": true,
        "datetime": "2025-12-22T22:55:29Z"
    },
    "linked-list-cycle": {
        "id": "linked-list-cycle",
        "title": "141. Linked List Cycle",
        "directory": "141-linked-list-cycle",
        "difficulty": "Easy",
        "tags": [
            "linked-list"
        ],
        "notes": "## Intuition\nFloyd's cycle detection: use two pointers moving at different speeds. If there's a cycle, the fast pointer will eventually lap the slow pointer and they'll meet. If no cycle, fast will reach the end.\n\n## Implementation\nInitialize both slow and fast pointers at the head. Move slow by one step and fast by two steps each iteration. If they ever point to the same node, a cycle exists. If fast reaches None or fast.next is None, there's no cycle.\n\n## Edge-cases\nCheck both fast and fast.next before advancing to avoid null pointer errors when the list is short or has no cycle.\n\n## Complexity\nTime `O(n)` since fast pointer moves twice as fast and will either exit or catch up within n steps. Space `O(1)` using only two pointers.\n",
        "published": true,
        "datetime": "2025-12-22T23:31:36Z"
    },
    "reorder-list": {
        "id": "reorder-list",
        "title": "143. Reorder List",
        "directory": "143-reorder-list",
        "difficulty": "Medium",
        "tags": [
            "linked-list"
        ],
        "notes": "## Intuition\nThe reordered list alternates between nodes from the start and nodes from the end. Achieve this by finding the middle, reversing the second half, and then interleaving the two halves.\n\n## Implementation\nThree steps: (1) Find the middle using slow/fast pointers, with fast starting at head.next for correct splitting. (2) Reverse the second half starting from slow.next, breaking the link by setting slow.next to None. (3) Merge by alternating nodes from both halves.\n\n## Edge-cases\nThe merging loop continues while the second half has nodes. Since the first half may be one node longer (odd length lists), this works correctly.\n\n## Complexity\nTime `O(n)` for three sequential linear operations. Space `O(1)` modifying the list in place.\n",
        "published": true,
        "datetime": "2025-12-23T22:09:36Z"
    },
    "invert-binary-tree": {
        "id": "invert-binary-tree",
        "title": "226. Invert Binary Tree",
        "directory": "226-invert-binary-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "bfs"
        ],
        "notes": "## Intuition\nInverting a binary tree means swapping every node's left and right children. We can visit every node using either BFS or DFS and perform the swap.\n\n## Implementation\nUsing BFS: initialize a queue with the root. For each node dequeued, swap its left and right children, then enqueue both children if they exist. Continue until the queue is empty. Return the original root reference.\n\n## Edge-cases\nIf the root is None, return None immediately\u2014there's nothing to invert.\n\n## Complexity\nTime `O(n)` visiting every node once. Space `O(n)` for the queue, which at worst holds an entire level of the tree.\n",
        "published": true,
        "datetime": "2025-12-23T23:19:16Z"
    },
    "maximum-depth-of-binary-tree": {
        "id": "maximum-depth-of-binary-tree",
        "title": "104. Maximum Depth of Binary Tree",
        "directory": "104-maximum-depth-of-binary-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "## Intuition\nThe maximum depth is the longest path from root to any leaf. Recursively, it's 1 plus the maximum of the left and right subtree depths.\n\n## Implementation\nUse DFS with a recursive function that returns the depth. Base case: if the node is None, return the current depth (0 if counting edges, or the accumulated depth if passing it down). Otherwise, return the maximum of recursing on left and right children with incremented depth.\n\n## Edge-cases\nAn empty tree (root is None) has depth 0.\n\n## Complexity\nTime `O(n)` visiting every node. Space `O(h)` where h is the tree height, due to the recursive call stack. In the worst case (skewed tree), this is O(n).\n",
        "published": true,
        "datetime": "2025-12-23T23:32:18Z"
    },
    "diameter-of-binary-tree": {
        "id": "diameter-of-binary-tree",
        "title": "543. Diameter of Binary Tree",
        "directory": "543-diameter-of-binary-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "## Intuition\nThe diameter passes through some node where it equals the sum of the left subtree height plus the right subtree height. We need to check this sum at every node while computing heights.\n\n## Implementation\nUse DFS to compute heights while tracking the maximum diameter found. For each node, compute left and right subtree heights recursively. Update the global maximum with left_height + right_height. Return 1 + max(left, right) as this node's height contribution.\n\n## Edge-cases\nIn Python, use the `nonlocal` keyword to modify a variable from an enclosing scope within the nested DFS function.\n\n## Complexity\nTime `O(n)` visiting every node once. Space `O(h)` for the call stack, which is O(n) in the worst case.\n",
        "published": true,
        "datetime": "2025-12-24T05:55:35Z"
    },
    "remove-nth-node-from-end-of-list": {
        "id": "remove-nth-node-from-end-of-list",
        "title": "19. Remove Nth Node From End of List",
        "directory": "19-remove-nth-node-from-end-of-list",
        "difficulty": "Medium",
        "tags": [
            "linked-list"
        ],
        "notes": "## Intuition\nBy maintaining two pointers n nodes apart, when the right pointer reaches the end, the left pointer is at the node just before the one to remove.\n\n## Implementation\nAdvance the right pointer n positions. Create a dummy node pointing to head to handle edge cases. Position left at the dummy. Move both pointers together until right reaches None. Now left.next is the target node\u2014skip it by setting left.next = left.next.next.\n\n## Edge-cases\nThe dummy node handles removing the head node (when n equals list length). Without it, we'd need special logic for that case.\n\n## Complexity\nTime `O(n)` for a single pass. Space `O(1)` using only pointers.\n",
        "published": true,
        "datetime": "2025-12-24T07:25:36Z"
    },
    "add-two-numbers": {
        "id": "add-two-numbers",
        "title": "2. Add Two Numbers",
        "directory": "2-add-two-numbers",
        "difficulty": "Medium",
        "tags": [
            "linked-list",
            "math"
        ],
        "notes": "## Intuition\nAdd digits from both lists like pencil-and-paper arithmetic\u2014sum corresponding digits plus any carry, keep the ones digit, carry the tens digit to the next position.\n\n## Implementation\nUse a dummy node for the result. Iterate while either list has nodes or there's a carry. For each position, sum the available values plus carry. The new digit is sum % 10, and the new carry is sum // 10. After both lists are exhausted, if carry remains, add one final node.\n\n## Edge-cases\nDon't forget to handle remaining carry after processing both lists. Lists of different lengths are handled naturally by treating exhausted lists as contributing zero.\n\n## Complexity\nTime `O(max(m, n))` where m and n are list lengths. Space `O(1)` excluding the result list.\n",
        "published": true,
        "datetime": "2025-12-24T07:52:29Z"
    },
    "find-the-duplicate-number": {
        "id": "find-the-duplicate-number",
        "title": "287. Find the Duplicate Number",
        "directory": "287-find-the-duplicate-number",
        "difficulty": "Medium",
        "tags": [
            "linked-list",
            "array"
        ],
        "notes": "## Intuition\nTreat the array as a linked list where each value points to the next index. A duplicate value means two indices point to the same location\u2014forming a cycle. Finding the duplicate is equivalent to finding where the cycle begins.\n\n## Implementation\nUse Floyd's algorithm in two phases. Phase 1: fast and slow pointers starting at index 0, where the \"next\" of index i is nums[i]. They'll meet inside the cycle. Phase 2: reset one pointer to the start and move both at the same speed\u2014they'll meet at the cycle's entrance, which is the duplicate.\n\n## Edge-cases\nThe second phase is essential\u2014the first meeting point is somewhere in the cycle, not necessarily at its start. The duplicate is specifically at the cycle entrance.\n\n## Complexity\nTime `O(n)` for both phases. Space `O(1)` using only pointers.\n",
        "published": true,
        "datetime": "2025-12-24T22:33:29Z"
    },
    "trapping-rain-water": {
        "id": "trapping-rain-water",
        "title": "42. Trapping Rain Water",
        "directory": "42-trapping-rain-water",
        "difficulty": "Hard",
        "tags": [
            "two-pointers",
            "math"
        ],
        "notes": "## Intuition\nWater at any position is bounded by the minimum of the maximum heights to its left and right, minus its own height. We can compute this efficiently using two pointers tracking the max heights seen from each direction.\n\n## Implementation\nUse left and right pointers starting at the ends. Track maxL (max height seen from left) and maxR (max height seen from right). If maxL <= maxR, the left side is the bottleneck\u2014calculate water at left pointer using maxL, then move left. Otherwise, calculate at right pointer using maxR and move right.\n\n## Edge-cases\nNo water can be trapped at the first and last positions since there's no wall on one side.\n\n## Complexity\nTime `O(n)` for a single pass. Space `O(1)` using only pointers and max trackers.\n",
        "published": true,
        "datetime": "2025-12-26T20:38:36Z"
    },
    "sliding-window-maximum": {
        "id": "sliding-window-maximum",
        "title": "239. Sliding Window Maximum",
        "directory": "239-sliding-window-maximum",
        "difficulty": "Hard",
        "tags": [
            "sliding-window"
        ],
        "notes": "## Intuition\nUse a monotonic decreasing deque that stores indices. The front always holds the maximum for the current window. Remove elements from the back that are smaller than the incoming element (they can never be the maximum), and remove from the front when indices fall outside the window.\n\n## Implementation\nMaintain a deque of indices in decreasing order of their values. For each new element: (1) remove smaller elements from the back, (2) add the current index, (3) remove the front if it's outside the window, (4) once the window reaches size k, record the front as the maximum.\n\n## Edge-cases\nThe deque stores indices, not values\u2014this allows checking whether elements have left the window. Only start recording answers once the window has reached full size (when r + 1 >= k).\n\n## Complexity\nTime `O(n)` since each element is added and removed from the deque at most once. Space `O(k)` for the deque.\n",
        "published": true,
        "datetime": "2025-12-27T22:29:30Z"
    },
    "balanced-binary-tree": {
        "id": "balanced-binary-tree",
        "title": "110. Balanced Binary Tree",
        "directory": "110-balanced-binary-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree"
        ],
        "notes": "## Intuition\nA tree is balanced if every node's left and right subtrees differ in height by at most 1. Compute heights recursively, using -1 as a sentinel to propagate imbalance upward.\n\n## Implementation\nCreate a height function that returns -1 if imbalanced. Base case: None returns 0. Recursively get left and right heights. If either is -1, or their difference exceeds 1, return -1. Otherwise return 1 + max(left, right). The tree is balanced if the root's height is not -1.\n\n## Edge-cases\nThe sentinel -1 allows early termination\u2014once we find imbalance anywhere, we stop computing heights and propagate the failure upward.\n\n## Complexity\nTime `O(n)` visiting each node once. Space `O(h)` for the recursive call stack.\n",
        "published": true,
        "datetime": "2026-01-02T22:58:23Z"
    },
    "same-tree": {
        "id": "same-tree",
        "title": "100. Same Tree",
        "directory": "100-same-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "## Intuition\nTwo trees are the same if their structures are identical and corresponding nodes have equal values. Recursively compare nodes in parallel.\n\n## Implementation\nBase case: if both nodes are None, they're equal. If exactly one is None or their values differ, they're not equal. Otherwise, recursively check that both left subtrees are the same AND both right subtrees are the same.\n\n## Edge-cases\nThe comparison handles all combinations: both None (equal), one None (not equal), both present (compare values and recurse).\n\n## Complexity\nTime `O(n)` visiting each node. Space `O(h)` for the recursive call stack, where h is the tree height.\n",
        "published": true,
        "datetime": "2026-01-03T07:12:18Z"
    },
    "subtree-of-another-tree": {
        "id": "subtree-of-another-tree",
        "title": "572. Subtree of Another Tree",
        "directory": "572-subtree-of-another-tree",
        "difficulty": "Easy",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "## Intuition\nCheck if subRoot matches the tree rooted at any node of root. Use the \"same tree\" comparison at each node of root.\n\n## Implementation\nCreate a helper function to check if two trees are identical (same structure and values). For the main function: if subRoot is None, it's trivially a subtree. If root is None but subRoot isn't, return False. Check if root matches subRoot using the helper. If not, recursively check the left and right subtrees of root.\n\n## Edge-cases\nA None subRoot is always a subtree. A None root with non-None subRoot is never a match.\n\n## Complexity\nTime `O(m * n)` in the worst case, comparing at each of n nodes with m-node comparison. Space `O(h)` for recursion depth.\n",
        "published": true,
        "datetime": "2026-01-12T19:01:22Z"
    },
    "lowest-common-ancestor-of-a-binary-search-tree": {
        "id": "lowest-common-ancestor-of-a-binary-search-tree",
        "title": "235. Lowest Common Ancestor of a Binary Search Tree",
        "directory": "235-lowest-common-ancestor-of-a-binary-search-tree",
        "difficulty": "Medium",
        "tags": [
            "binary-tree",
            "dfs"
        ],
        "notes": "## Intuition\nIn a BST, the LCA is the first node where p and q diverge\u2014one goes left, the other goes right (or one equals the current node). This is the split point in the BST ordering.\n\n## Implementation\nStart at the root. If both p and q are greater than current, move right. If both are less, move left. Otherwise, current is the LCA\u2014either it's a split point, or one of p/q equals current.\n\n## Edge-cases\nThe problem guarantees valid inputs with p and q existing in the tree, so no null checks needed beyond the traversal.\n\n## Complexity\nTime `O(h)` where h is the tree height. Space `O(1)` using iterative traversal.\n",
        "published": true,
        "datetime": "2026-01-12T19:58:25Z"
    },
    "max-level-party-invites": {
        "id": "max-level-party-invites",
        "title": "Max Level Party Invites",
        "directory": "max-level-party-invites",
        "difficulty": "Hard",
        "tags": [
            "graph",
            "dp",
            "dfs"
        ],
        "notes": "## Intuition\nThis is a tree DP problem similar to House Robber III. For each node, we track two states: the maximum sum if we invite this node (must skip children) versus if we skip this node (can choose either for children).\n\n## Implementation\nBuild an adjacency list from the reporting chain and identify root nodes (those without parents). DFS from each root computing two values per node: `invite` (node's level + sum of children's skip values) and `skip` (sum of max(invite, skip) for each child). Memoize results to avoid recomputation.\n\n## Edge-cases\nThe graph may have multiple disconnected trees (multiple roots). Process each root separately and sum their contributions.\n\n## Complexity\nTime `O(n)` with memoization ensuring each node is processed once. Space `O(n)` for the adjacency list and memoization map.\n",
        "published": true,
        "datetime": "2026-01-13T03:15:05Z"
    },
    "minimum-lock-turns": {
        "id": "minimum-lock-turns",
        "title": "Minimum Lock Turns",
        "directory": "minimum-lock-turns",
        "difficulty": "Medium",
        "tags": [
            "graph",
            "bfs"
        ],
        "notes": "## Intuition\nTreat each combination as a node in a graph where edges connect combinations differing by one wheel turn. BFS finds the shortest path from start to target.\n\n## Implementation\nCreate a neighbor function that generates all 8 possible combinations from one turn (each of 4 wheels can go up or down). BFS from start: for each combination, try all neighbors. Skip blocked or visited combinations. Return the number of turns when we reach the target.\n\n## Edge-cases\nIf start equals target, return 0. If start is blocked, return -1 immediately since no moves are possible.\n\n## Complexity\nTime `O(10^4 * 8)` for BFS over all possible states, each with 8 neighbors. Space `O(10^4)` for visited set.\n",
        "published": true,
        "datetime": "2026-01-13T05:23:25Z"
    },
    "rummy-card-game": {
        "id": "rummy-card-game",
        "title": "Rummy Card Game",
        "directory": "rummy-card-game",
        "difficulty": "Hard",
        "tags": [
            "sliding-window",
            "math"
        ],
        "notes": "## Intuition\nRummy melds are either sets (3+ cards of same rank, different suits) or runs (3+ consecutive cards of same suit). Group cards by rank for sets and by suit for runs, then generate all valid combinations.\n\n## Implementation\nGroup cards into two hashmaps: by rank and by suit. For sets, generate all combinations of 3+ cards with the same rank. For runs, sort cards by rank within each suit, find consecutive sequences, and generate all windows of 3+ consecutive cards.\n\n## Edge-cases\nOnly process groups with at least 3 cards. When building consecutive sequences, flush the current segment when a gap is found, then start a new segment.\n\n## Complexity\nTime `O(n^2)` due to generating combinations. Space `O(n^2)` for storing all possible melds.\n",
        "published": true,
        "datetime": "2026-01-13T07:01:53Z"
    },
    "skyscraper-furthest-distance": {
        "id": "skyscraper-furthest-distance",
        "title": "Skyscraper Furthest Distance",
        "directory": "skyscraper-furthest-distance",
        "difficulty": "Medium",
        "tags": [
            "heap"
        ],
        "notes": "## Intuition\nSprings should be used for the largest height differences to maximize distance. Greedily use sandbags first, then retroactively convert the largest sandbag uses to springs when sandbags run out.\n\n## Implementation\nUse a max heap (via negation in Python) to track height differences. For each upward jump, initially use sandbags and push the difference to the heap. When sandbags go negative, convert the largest previous sandbag use to a spring by popping from the heap and restoring those sandbags.\n\n## Edge-cases\nIf sandbags go negative and no springs remain, return the current index\u2014we can't proceed further. Python uses min heap, so negate values for max heap behavior.\n\n## Complexity\nTime `O(n log n)` for n heap operations. Space `O(n)` for the heap.\n",
        "published": true,
        "datetime": "2026-01-13T20:11:29Z"
    },
    "open-the-lock": {
        "id": "open-the-lock",
        "title": "752. Open the Lock",
        "directory": "752-open-the-lock",
        "difficulty": "Medium",
        "tags": [
            "graph",
            "bfs"
        ],
        "notes": "## Intuition\nModel the lock as a graph where each 4-digit combination is a node, connected to 8 neighbors (each wheel can turn up or down). BFS finds the minimum turns from \"0000\" to the target.\n\n## Implementation\nGenerate neighbors by incrementing or decrementing each digit (mod 10). BFS from \"0000\": skip deadends and visited states, return turn count when reaching target. Track visited states to avoid cycles.\n\n## Edge-cases\nCheck if \"0000\" is in deadends\u2014if so, return -1 immediately. Also handle the case where start equals target.\n\n## Complexity\nTime `O(10^4 * 8)` for BFS across all possible combinations. Space `O(10^4)` for the visited set and queue.\n",
        "published": true,
        "datetime": "2026-01-13T20:51:21Z"
    },
    "furthest-building-you-can-reach": {
        "id": "furthest-building-you-can-reach",
        "title": "1642. Furthest Building You Can Reach",
        "directory": "1642-furthest-building-you-can-reach",
        "difficulty": "Medium",
        "tags": [
            "heap"
        ],
        "notes": "## Intuition\nLadders should be reserved for the largest climbs since they handle any height. Use bricks first, and when bricks run out, retroactively convert the largest brick usage to a ladder.\n\n## Implementation\nTrack all climbs in a max heap. For each climb, use bricks and push the climb to the heap. If bricks go negative, use a ladder instead: pop the largest climb from the heap and add those bricks back. If no ladders remain when needed, return the current index.\n\n## Edge-cases\nDownward moves (negative differences) are free\u2014skip them. Return the last index if we successfully traverse the entire array.\n\n## Complexity\nTime `O(n log n)` for heap operations. Space `O(n)` for the heap.\n",
        "published": true,
        "datetime": "2026-01-13T21:03:19Z"
    },
    "1730-shortest-path-to-get-food": {
        "id": "1730-shortest-path-to-get-food",
        "title": "1730. Shortest Path To Get Food",
        "directory": "1730-shortest-path-to-get-food",
        "difficulty": "Medium",
        "tags": [
            "graph",
            "bfs"
        ],
        "notes": "## Intuition\nThis is a standard BFS shortest path problem on a grid. Start from the initial position and explore all reachable cells level by level until finding food.\n\n## Implementation\nLocate the start cell (marked with '*'). BFS from there: for each cell, check all four neighbors. Skip visited cells and obstacles ('X'). When reaching a food cell ('#'), return the path length. Mark cells as visited when adding to the queue.\n\n## Edge-cases\nIf no path to food exists (all food is blocked or unreachable), return -1 after BFS completes.\n\n## Complexity\nTime `O(m * n)` visiting each cell at most once. Space `O(m * n)` for the visited set and queue.\n",
        "published": true,
        "datetime": "2026-01-13T23:04:22Z"
    },
    "infinite-taxi-driver": {
        "id": "infinite-taxi-driver",
        "title": "Infinite Taxi Driver",
        "directory": "infinite-taxi-driver",
        "difficulty": "Medium",
        "tags": [
            "graph",
            "bfs"
        ],
        "notes": "## Intuition\nOn an infinite grid with obstacles, BFS finds the shortest path while building a direction string. Each move adds its cardinal direction (N, S, E, W) to the path.\n\n## Implementation\nBFS from start, tracking both the coordinate and the path string. Generate 4 neighbors (N, S, E, W) for each position. Skip barriers and visited cells. When reaching the target, return the accumulated direction string.\n\n## Edge-cases\nNo bounds checking needed since the grid is infinite. If start equals target, return an empty string.\n\n## Complexity\nTime and Space `O(d^2)` where d is the distance to target, since BFS explores in expanding circles. Could be optimized with A* using Manhattan distance heuristic.\n",
        "published": true,
        "datetime": "2026-01-14T17:50:43Z"
    },
    "merge-strings-alternately": {
        "id": "merge-strings-alternately",
        "title": "1768. Merge Strings Alternately",
        "directory": "1768-merge-strings-alternately",
        "difficulty": "Easy",
        "tags": [
            "two-pointers"
        ],
        "notes": "## Intuition\nAlternate between the two strings, taking one character at a time from each. When one string is exhausted, append the remainder of the other.\n\n## Implementation\nUse two pointers (i for word1, j for word2) and a counter k. While both strings have characters remaining, add from word1 when k is even, from word2 when k is odd. After one string is exhausted, append any remaining characters from the other.\n\n## Edge-cases\nStrings may have different lengths. The remaining characters from the longer string are simply appended at the end.\n\n## Complexity\nTime `O(n + m)` touching each character once. Space `O(1)` excluding the output string.\n",
        "published": true,
        "datetime": "2026-01-25T00:44:15Z"
    },
    "increasing-triplet-subsequence": {
        "id": "increasing-triplet-subsequence",
        "title": "334. Increasing Triplet Subsequence",
        "directory": "334-increasing-triplet-subsequence",
        "difficulty": "Medium",
        "tags": [
            "math",
            "trick"
        ],
        "notes": "## Intuition\nTrack the smallest value and the smallest value that comes after it. If we ever find a third value larger than both, we have an increasing triplet.\n\n## Implementation\nMaintain two variables: `smallest` (minimum so far) and `second_smallest` (minimum value following some smaller value). For each number: if it's <= smallest, update smallest. Else if it's <= second_smallest, update second_smallest. Else, we found a value > second_smallest > smallest\u2014return True.\n\n## Edge-cases\nThe values don't need to be contiguous in the array. We're finding any increasing subsequence of length 3.\n\n## Complexity\nTime `O(n)` for a single pass. Space `O(1)` using only two tracking variables.\n",
        "published": true,
        "datetime": "2026-01-26T05:22:10Z"
    },
    "string-compression": {
        "id": "string-compression",
        "title": "443. String Compression",
        "directory": "443-string-compression",
        "difficulty": "Medium",
        "tags": [
            "two-pointers"
        ],
        "notes": "## Intuition\nUse three pointers: left marks the start of a character group, right scans for the group's end, and write tracks where to put the compressed output. Compress in-place by overwriting the input array.\n\n## Implementation\nFor each group of consecutive identical characters: (1) advance right until the character changes, (2) write the character at the write pointer, (3) if the count > 1, write each digit of the count. Then move left to right's position and repeat.\n\n## Edge-cases\nWhen count > 9, write each digit separately (e.g., 12 becomes '1' then '2'). Single-character groups don't need a count.\n\n## Complexity\nTime `O(n)` processing each character once. Space `O(1)` modifying the array in place.\n",
        "published": true,
        "datetime": "2026-01-26T06:03:49Z"
    }
}